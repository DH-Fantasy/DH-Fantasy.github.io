<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DH-Fantasy</title>
  
  <subtitle>勇于探索未知领域，不断提升自己。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-26T14:04:48.592Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>DH-Fantasy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS iPv6审核被拒</title>
    <link href="http://example.com/2019/01/06/iOS%20iPv6%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92/"/>
    <id>http://example.com/2019/01/06/iOS%20iPv6%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92/</id>
    <published>2019-01-06T10:30:15.000Z</published>
    <updated>2020-09-26T14:04:48.592Z</updated>
    
    <content type="html"><![CDATA[<p>iPv6被拒可分为三个方面的问题：1.App不支持；2.服务器不支持；3.所处网络环境不支持。</p><ul><li>App是否支持iPv6？搭建一个iPv6测试网络进行验证。<br>搭建方法：</li></ul><p>1.苹果官方文档介绍了iPv6以及如何使用Mac建立本地iPv6 Wi-Fi网络<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW1">Supporting IPv6 DNS64/NAT64 Networks</a><br>2.<a href="http://www.cocoachina.com/ios/20160525/16431.html">【指南】本地如何搭建IPv6环境测试你的APP</a></p><ul><li>服务器是否支持iPv6？使用命令检测服务器是否支持iPv6。<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd +nostats 域名 AAAA</span><br></pre></td></tr></table></figure>结果status返回noerror则表明服务器支持iPv6。</li></ul><p>此外，连接服务器失败，苹果也会视为iPv6的问题。在排除了App问题和服务器问题后，可以通过查看服务器日志，以验证iPv6流量是否被正确处理。</p><p>笔者通过服务器日志发现，受公司iP安全策略影响，国外不能访问。对此只需要调整iP安全策略，然后发件给审核人员说明情况就行。</p><p><img src="https://upload-images.jianshu.io/upload_images/1690826-4c0b5c7878370e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发件截图"></p><p>####参考链接：<br><a href="https://www.jianshu.com/p/39fda70437c6">1.关于IPV6审核被拒的完整分析</a><br><a href="https://www.jianshu.com/p/a6bab07c4062">2.iOS应用支持IPV6，就那点事儿</a><br><a href="https://www.jianshu.com/p/5e06e8dd2fc4">3.iOS上线之IPv6</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iPv6被拒可分为三个方面的问题：1.App不支持；2.服务器不支持；3.所处网络环境不支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App是否支持iPv6？搭建一个iPv6测试网络进行验证。&lt;br&gt;搭建方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.苹果官方文档介绍了iPv6以及如何使用Mac建立本地iPv6 Wi-Fi网络&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/UnderstandingandPreparingfortheIPv6Transition/UnderstandingandPreparingfortheIPv6Transition.html#//apple_ref/doc/uid/TP40010220-CH213-SW1&quot;&gt;Supporting IPv6 DNS64/NAT64 Networks&lt;/a&gt;&lt;br&gt;2.&lt;a href=&quot;http://www.cocoachina.com/ios/20160525/16431.html&quot;&gt;【指南】本地如何搭建IPv6环境测试你的APP&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器是否支持iPv6？使用命令检测服务器是否支持iPv6。</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="审核" scheme="http://example.com/tags/%E5%AE%A1%E6%A0%B8/"/>
    
    <category term="iPv6" scheme="http://example.com/tags/iPv6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 侧滑抽屉效果</title>
    <link href="http://example.com/2017/11/05/iOS%20%E4%BE%A7%E6%BB%91%E6%8A%BD%E5%B1%89%E6%95%88%E6%9E%9C/"/>
    <id>http://example.com/2017/11/05/iOS%20%E4%BE%A7%E6%BB%91%E6%8A%BD%E5%B1%89%E6%95%88%E6%9E%9C/</id>
    <published>2017-11-05T12:30:53.000Z</published>
    <updated>2020-09-26T14:06:41.489Z</updated>
    
    <content type="html"><![CDATA[<p>项目改版新需求要求实现类似QQ侧滑效果。</p><p>讲下思路：<br>1.使用一个UIViewController作为容器（Demo中的MainViewController）；<br>2.将MainViewController赋值给window的rootViewController时包装一层UINavigationController；<br>3.为MainViewController添加两个childViewController；<br>4.在MainViewController的viewWillAppear中对导航栏进行隐藏，并设置translucent为YES；<br>5.添加UIPanGestureRecognizer手势实现展开、隐藏动画；</p><a id="more"></a><p><a href="https://github.com/DH-Fantasy/MenuDemo">Demo地址</a></p><p>Demo效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/1690826-42d1ff9e36c849c4.gif?imageMogr2/auto-orient/strip" alt="效果图"></p><p>####参考链接<br><a href="http://www.jianshu.com/p/a8ed1c400db7">iOS 模仿QQ侧滑菜单和UITabBar拖动动画(Swift实现)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目改版新需求要求实现类似QQ侧滑效果。&lt;/p&gt;
&lt;p&gt;讲下思路：&lt;br&gt;1.使用一个UIViewController作为容器（Demo中的MainViewController）；&lt;br&gt;2.将MainViewController赋值给window的rootViewController时包装一层UINavigationController；&lt;br&gt;3.为MainViewController添加两个childViewController；&lt;br&gt;4.在MainViewController的viewWillAppear中对导航栏进行隐藏，并设置translucent为YES；&lt;br&gt;5.添加UIPanGestureRecognizer手势实现展开、隐藏动画；&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="侧滑抽屉" scheme="http://example.com/tags/%E4%BE%A7%E6%BB%91%E6%8A%BD%E5%B1%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS 同步服务器时间</title>
    <link href="http://example.com/2017/08/12/iOS%20%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4/"/>
    <id>http://example.com/2017/08/12/iOS%20%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4/</id>
    <published>2017-08-12T14:38:15.000Z</published>
    <updated>2020-09-26T14:05:15.826Z</updated>
    
    <content type="html"><![CDATA[<p>　　在项目中遇到需要同步服务器时间的需求，解决方案如下。</p><p>1.App启动后获取服务器当前时间时间戳ServerTimeStampA，获取成功后保存至本地，并同时保存客户端当前时间时间戳LocalTimeStampA；<br>2.在需要使用到服务器时间时，先获取客户端当前时间时间戳LocalTimeStampB,再获取interval = LocalTimeStampB - LocalTimeStampA，服务器时间时间戳即为：ServerTimeStampA + interval，将其转换为时间即可；<br>3.如果获取服务器时间失败，则视服务器时间与本地时间相同；<br>4.使用NSSystemClockDidChangeNotification监测系统时间发生改变 ，如果系统时间发生改变则重新获取一次服务器时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取服务器时间并保持至本地</span><br><span class="line">double serverTimeStamp &#x3D; 1502534359727.2739; &#x2F;&#x2F; 模拟服务器当前时间时间戳，精确到毫秒</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setDouble:serverTimeStamp forKey:kLastSaveServerTimeStamp];</span><br><span class="line">double currentLocalTimeStamp &#x3D; [[NSDate date] timeIntervalSince1970] * 1000;</span><br><span class="line">[[NSUserDefaults standardUserDefaults]setDouble:currentLocalTimeStamp forKey:kLastSaveLocalTimeStamp];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure><p>获取服务器时间有两种方法<br>方法一：服务端同学给一个获取服务器时间接口；<br>方法二：通过HTTP Header来获取服务器时间（注：时间格式以<a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC-7231</a>中定义的”HTTP日期”格式来发送，见下图）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取HTTP Header</span><br><span class="line">NSHTTPURLResponse *response &#x3D; (NSHTTPURLResponse *)task.response;</span><br><span class="line">NSDictionary *allHeaders &#x3D; response.allHeaderFields;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-72cdca080a1e4e1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP Header"></p><p>将HTTP Header中的时间转换为NSDate可使用<a href="https://github.com/mwaterfall/MWFeedParser/blob/master/Classes/NSDate+InternetDateTime.m">NSDate+InternetDateTime.m</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 转换方法</span><br><span class="line">NSDate *inputDate &#x3D; [NSDate dateFromInternetDateTimeString:dateServer formatHint:DateFormatHintRFC822];</span><br><span class="line"></span><br><span class="line">NSDate *inputDate &#x3D; [NSDate dateFromRFC822String:dateServer];</span><br></pre></td></tr></table></figure><p>为NSDate创建Category</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务器当前时间戳（精确到毫秒）</span><br><span class="line">+ (double)serverCurrentTimeStamp&#123;</span><br><span class="line">    &#x2F;&#x2F; 最后保存的服务器时间戳</span><br><span class="line">    double lastSaveServerTimeStamp &#x3D; [[NSUserDefaults standardUserDefaults] doubleForKey:kLastSaveServerTimeStamp];</span><br><span class="line">    &#x2F;&#x2F; 最后保存服务器时间戳时的本地时间戳</span><br><span class="line">    double lastSaveLocalTimeStamp &#x3D; [[NSUserDefaults standardUserDefaults] doubleForKey:kLastSaveLocalTimeStamp];</span><br><span class="line">    &#x2F;&#x2F; 当前本地时间戳</span><br><span class="line">    double currentLocalTimeStamp &#x3D; [[NSDate date] timeIntervalSince1970] * 1000;</span><br><span class="line">    </span><br><span class="line">    if (lastSaveLocalTimeStamp !&#x3D; 0 || lastSaveServerTimeStamp !&#x3D; 0) &#123;</span><br><span class="line">        return lastSaveServerTimeStamp + (currentLocalTimeStamp - lastSaveLocalTimeStamp);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F; 如果没有获取到服务器时间，说明客户端还没开始用过，则视服务器时间与本地时间相同</span><br><span class="line">        return  currentLocalTimeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务器当前时间</span><br><span class="line">+ (NSDate *)serverCurrentDate&#123;</span><br><span class="line">    double serverTimeStamp &#x3D; [NSDate serverCurrentTimeStamp] &#x2F; 1000;</span><br><span class="line">    NSDate *serverDateZone &#x3D; [NSDate dateWithTimeIntervalSince1970:(serverTimeStamp)];</span><br><span class="line">    NSTimeZone *timeZone &#x3D; [NSTimeZone systemTimeZone];</span><br><span class="line">    NSInteger interval &#x3D; [timeZone secondsFromGMTForDate:serverDateZone];</span><br><span class="line">    NSDate *serverDate &#x3D; [serverDateZone dateByAddingTimeInterval:interval];</span><br><span class="line">    return serverDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####参考链接<br><a href="http://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html">1.时间与日期处理</a><br><a href="https://my.oschina.net/ioslighter/blog/420716">2.通过AFNetworking获取服务器时间 </a><br><a href="http://mrpeak.cn/blog/ios-time/">3.iOS关于时间的处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　在项目中遇到需要同步服务器时间的需求，解决方案如下。&lt;/p&gt;
&lt;p&gt;1.App启动后获取服务器当前时间时间戳ServerTimeStampA，获取成功后保存至本地，并同时保存客户端当前时间时间戳LocalTimeStampA；&lt;br&gt;2.在需要使用到服务器时间时，先获取</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="时间同步" scheme="http://example.com/tags/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>iOS 使用NJKWebViewProgress做webview进度条（加载网页时获取加载进度）</title>
    <link href="http://example.com/2017/03/26/iOS%20%E4%BD%BF%E7%94%A8NJKWebViewProgress%E5%81%9Awebview%E8%BF%9B%E5%BA%A6%E6%9D%A1%EF%BC%88%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B5%E6%97%B6%E8%8E%B7%E5%8F%96%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%EF%BC%89/"/>
    <id>http://example.com/2017/03/26/iOS%20%E4%BD%BF%E7%94%A8NJKWebViewProgress%E5%81%9Awebview%E8%BF%9B%E5%BA%A6%E6%9D%A1%EF%BC%88%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B5%E6%97%B6%E8%8E%B7%E5%8F%96%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%EF%BC%89/</id>
    <published>2017-03-26T15:54:45.000Z</published>
    <updated>2020-09-26T14:05:28.838Z</updated>
    
    <content type="html"><![CDATA[<p>使用到的第三方库：<a href="https://github.com/ninjinkun/NJKWebViewProgress">NJKWebViewProgress</a></p><p>使用：采用代理方式，在代理中获取进度，并赋值给进度条。具体看代码。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;NJKWebViewProgress.h&quot;</span><br><span class="line">#import &quot;NJKWebViewProgressView.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;UIWebViewDelegate,NJKWebViewProgressDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIView *maskView;</span><br><span class="line">@property (nonatomic, strong) UIView *urlInputView;</span><br><span class="line">@property (nonatomic, strong) UITextField *urlInput;</span><br><span class="line">@property (nonatomic, strong) UIWebView *webView;</span><br><span class="line">@property (nonatomic, strong) NJKWebViewProgressView *progressView;</span><br><span class="line">@property (nonatomic, strong) NJKWebViewProgress *progressProxy;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加进度条</span><br><span class="line">    [self.navigationController.navigationBar addSubview:self.progressView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 因为与其他viewcontroller共用一个UINavigationBar，所以需要移除进度条</span><br><span class="line">    [self.progressView removeFromSuperview];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.title &#x3D; @&quot;Test_WebViewProgress&quot;;</span><br><span class="line">    self.navigationController.navigationBar.translucent &#x3D; NO;</span><br><span class="line">    </span><br><span class="line">    self.webView &#x3D; [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height - 64)];</span><br><span class="line">    [self.view addSubview:self.webView];</span><br><span class="line">    </span><br><span class="line">    NSString *url &#x3D; @&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;b05772019513&quot;;</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:url forKey:@&quot;weburl&quot;];</span><br><span class="line">    </span><br><span class="line">    [self loadWithUrlStr:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    &#x2F;&#x2F; Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -- NJKWebViewProgressDelegate</span><br><span class="line">- (void)webViewProgress:(NJKWebViewProgress *)webViewProgress updateProgress:(float)progress&#123;</span><br><span class="line">    </span><br><span class="line">    [self.progressView setProgress:progress animated:YES];</span><br><span class="line">    </span><br><span class="line">    self.title &#x3D; [self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 重新加载*&#x2F;</span><br><span class="line">- (IBAction)reload:(id)sender &#123;</span><br><span class="line">    [self.webView reload];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 打开 url 输入面板*&#x2F;</span><br><span class="line">- (IBAction)onOpenUrlInput:(id)sender&#123;</span><br><span class="line">    </span><br><span class="line">    if (self.maskView &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        self.maskView &#x3D; [[UIView alloc]initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">        self.maskView.backgroundColor &#x3D; [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.75];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.urlInputView &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        self.urlInputView &#x3D; [[UIView alloc]initWithFrame:CGRectMake(0, 0, 300, 105)];</span><br><span class="line">        self.urlInputView.backgroundColor &#x3D; [UIColor lightGrayColor];</span><br><span class="line">        self.urlInputView.layer.cornerRadius &#x3D; 8.0f;</span><br><span class="line">        self.urlInputView.layer.masksToBounds &#x3D; YES;</span><br><span class="line">        </span><br><span class="line">        self.urlInput &#x3D; [[UITextField alloc]initWithFrame:CGRectMake(10, 15, 280, 30)];</span><br><span class="line">        self.urlInput.autocapitalizationType &#x3D; UITextAutocapitalizationTypeNone;</span><br><span class="line">        self.urlInput.autocorrectionType &#x3D; UITextAutocorrectionTypeNo;</span><br><span class="line">        self.urlInput.clearButtonMode &#x3D; UITextFieldViewModeWhileEditing;</span><br><span class="line">        self.urlInput.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">        self.urlInput.layer.cornerRadius &#x3D; 4.0f;</span><br><span class="line">        self.urlInput.layer.masksToBounds &#x3D; YES;</span><br><span class="line">        [self.urlInputView addSubview:self.urlInput];</span><br><span class="line">        </span><br><span class="line">        UIButton* btn &#x3D; [[UIButton alloc]initWithFrame:CGRectMake(230, 60, 60, 30)];</span><br><span class="line">        btn.backgroundColor &#x3D; [UIColor colorWithRed:81.0f&#x2F;255.0f green:141.0f&#x2F;255.0f blue:229.0f&#x2F;255.0f alpha:1.0f];</span><br><span class="line">        btn.layer.cornerRadius &#x3D; 4.0f;</span><br><span class="line">        btn.layer.masksToBounds &#x3D; YES;</span><br><span class="line">        </span><br><span class="line">        [btn setTitle:@&quot;Load&quot; forState:UIControlStateNormal];</span><br><span class="line">        [btn addTarget:self action:@selector(onOpenInputedUrl:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        [self.urlInputView addSubview:btn];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString* webUrl &#x3D; [[NSUserDefaults standardUserDefaults]objectForKey:@&quot;weburl&quot;];</span><br><span class="line">    self.urlInput.text &#x3D; webUrl;</span><br><span class="line">    </span><br><span class="line">    UIWindow* keyWnd &#x3D; [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    if (keyWnd) &#123;</span><br><span class="line">        if (self.maskView.superview) &#123;</span><br><span class="line">            [self.maskView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">        [keyWnd addSubview:self.maskView];</span><br><span class="line">        </span><br><span class="line">        if (self.urlInputView.superview) &#123;</span><br><span class="line">            [self.urlInputView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">        [keyWnd addSubview:self.urlInputView];</span><br><span class="line">        self.urlInputView.center &#x3D; keyWnd.center;</span><br><span class="line">        CGRect frame &#x3D; self.urlInputView.frame;</span><br><span class="line">        frame.origin.y &#x3D; 84;</span><br><span class="line">        self.urlInputView.frame &#x3D; frame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 点击 load 按钮 *&#x2F;</span><br><span class="line">- (void)onOpenInputedUrl:(id)sender&#123;</span><br><span class="line">    </span><br><span class="line">    if (self.urlInputView.superview) &#123;</span><br><span class="line">        [self.urlInputView removeFromSuperview];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.maskView.superview) &#123;</span><br><span class="line">        [self.maskView removeFromSuperview];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString* urlStr &#x3D; self.urlInput.text;</span><br><span class="line">    if (urlStr.length &gt; 0) &#123;</span><br><span class="line">        if (![urlStr hasPrefix:@&quot;http&quot;]) &#123;</span><br><span class="line">            urlStr &#x3D; [NSString stringWithFormat:@&quot;http:&#x2F;&#x2F;%@&quot;, urlStr];</span><br><span class="line">        &#125;</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setObject:urlStr forKey:@&quot;weburl&quot;];</span><br><span class="line">        [self loadWithUrlStr:urlStr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 导航条下面的进度条 *&#x2F;</span><br><span class="line">- (NJKWebViewProgressView *)progressView &#123;</span><br><span class="line">    if(!_progressView) &#123;</span><br><span class="line">        _progressProxy &#x3D; [[NJKWebViewProgress alloc] init];</span><br><span class="line">        _webView.delegate &#x3D; _progressProxy;</span><br><span class="line">        _progressProxy.webViewProxyDelegate &#x3D; self;</span><br><span class="line">        _progressProxy.progressDelegate &#x3D; self;</span><br><span class="line">        </span><br><span class="line">        CGFloat progressBarHeight &#x3D; 2.f;</span><br><span class="line">        CGRect navigaitonBarBounds &#x3D; self.navigationController.navigationBar.bounds;</span><br><span class="line">        CGRect barFrame &#x3D; CGRectMake(0, navigaitonBarBounds.size.height - progressBarHeight, navigaitonBarBounds.size.width, progressBarHeight);</span><br><span class="line">        _progressView &#x3D; [[NJKWebViewProgressView alloc] initWithFrame:barFrame];</span><br><span class="line">        _progressView.autoresizingMask &#x3D; UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleTopMargin;</span><br><span class="line">        _progressView.progressBarView.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">        _progressView.progress &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return _progressView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**加载 url *&#x2F;</span><br><span class="line">- (void)loadWithUrlStr:(NSString*)urlStr&#123;</span><br><span class="line">    </span><br><span class="line">    if (urlStr.length &gt; 0) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSURLRequest *webRequest &#x3D; [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]</span><br><span class="line">                                                        cachePolicy:NSURLRequestReturnCacheDataElseLoad</span><br><span class="line">                                                    timeoutInterval:30];</span><br><span class="line">            [self.webView loadRequest:webRequest];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-e1305656af3a1709.gif?imageMogr2/auto-orient/strip" alt="运行效果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用到的第三方库：&lt;a href=&quot;https://github.com/ninjinkun/NJKWebViewProgress&quot;&gt;NJKWebViewProgress&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用：采用代理方式，在代理中获取进度，并赋值给进度条。具体看代码。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="WebView" scheme="http://example.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>iOS 信号量机制</title>
    <link href="http://example.com/2017/03/19/iOS%20%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2017/03/19/iOS%20%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/</id>
    <published>2017-03-19T15:59:52.000Z</published>
    <updated>2020-09-26T14:05:07.863Z</updated>
    
    <content type="html"><![CDATA[<p>####信号量机制<br>　　在 iOS 系统及大部分现代操作系统中，多个线程可以并发执行，CPU在线程之间来回切换，共享某些资源，提高了资源的利用率。<strong>但是我们该如何处理各个线程之间的相互制约关系？</strong>比如只有一台打印机，两个线程都需要打印文件，如果直接让他们简单的并发访问打印机，那么很可能什么都打印不出来或者打印的文件是混乱的。显然，我们需要增加一种机制来控制线程间的相互制约关系。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-14ac4c6dab4df3ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450" alt="打印机乱码（图片来源于网络）"></p><p>　　简单来说就是我们需要一种机制来控制线程执行的先后顺序。</p><p>　　而信号量就可以提供这样的一种机制，让一个临界区（临界区指的是线程中访问共用资源的程序片段）同一时间只有一个线程在访问它，也就是说信号量是用来协调线程对共享资源的访问的。</p><a id="more"></a><p>　　信号量可以理解为是一个资源计数器，对信号量有两个操作来达到互斥，分别是P和V操作。 一般情况是这样进行临界访问或互斥访问的： 设信号量值为1， 当一个线程A运行时，使用资源，进行P操作，即对信号量值减1，也就是资源数少了1个。这时信号量值为0。系统中规定当信号量值为0是，必须等待，直到信号量值不为零才能继续操作。 这时如果线程B想要运行，那么也必须进行P操作，但是此时信号量为0，所以无法减1，即不能P操作，也就阻塞。这样就达到了线程A的排他访问。 当线程A运行结束后，释放资源，进行V操作。资源数重新加1，这时信号量的值变为1，这时线程B发现资源数不为0，信号量能进行P操作了，立即执行P操作。信号量值又变为0，线程B有资源，其余线程必须等到，达到线程B的排他访问。 这就是信号量来控制线程互斥的原理。</p><p>####GCD如何使用信号量<br>　　在GCD中有三个函数是semaphore的操作，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_create(long value); &#x2F;&#x2F; 创建一个semaphore　</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema); &#x2F;&#x2F; 发送一个信号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); &#x2F;&#x2F; 等到信号</span><br></pre></td></tr></table></figure><p>　　第一个函数有一个长整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建队列组</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();   </span><br><span class="line">&#x2F;&#x2F; 创建信号量，并且设置值为10</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(10);   </span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);   </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++)   </span><br><span class="line">    &#123;   &#x2F;&#x2F; 由于是异步执行的，所以每次循环Block里面的dispatch_semaphore_signal根本还没有执行就会执行dispatch_semaphore_wait，从而semaphore-1.当循环10此后，semaphore等于0，则会阻塞线程，直到执行了Block的dispatch_semaphore_signal 才会继续执行</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   </span><br><span class="line">        dispatch_group_async(group, queue, ^&#123;   </span><br><span class="line">            NSLog(@&quot;%i&quot;,i);   </span><br><span class="line">            sleep(2);   </span><br><span class="line">&#x2F;&#x2F; 每次发送信号则semaphore会+1，</span><br><span class="line">            dispatch_semaphore_signal(semaphore);   </span><br><span class="line">        &#125;);   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####总结<br>　　信号量是用在多线程并发的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。</p><p>####参考链接<br><a href="http://blog.chinaunix.net/uid-24599332-id-2122852.html">1.信号量与锁的差别</a><br><a href="http://www.jianshu.com/p/04ca5470f212">2.浅谈GCD中的信号量</a><br><a href="http://www.cnblogs.com/whatbeg/p/4435286.html">3.用信号量解决进程的同步与互斥探讨</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;####信号量机制&lt;br&gt;　　在 iOS 系统及大部分现代操作系统中，多个线程可以并发执行，CPU在线程之间来回切换，共享某些资源，提高了资源的利用率。&lt;strong&gt;但是我们该如何处理各个线程之间的相互制约关系？&lt;/strong&gt;比如只有一台打印机，两个线程都需要打印文件，如果直接让他们简单的并发访问打印机，那么很可能什么都打印不出来或者打印的文件是混乱的。显然，我们需要增加一种机制来控制线程间的相互制约关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1690826-14ac4c6dab4df3ec.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450&quot; alt=&quot;打印机乱码（图片来源于网络）&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　简单来说就是我们需要一种机制来控制线程执行的先后顺序。&lt;/p&gt;
&lt;p&gt;　　而信号量就可以提供这样的一种机制，让一个临界区（临界区指的是线程中访问共用资源的程序片段）同一时间只有一个线程在访问它，也就是说信号量是用来协调线程对共享资源的访问的。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="信号量" scheme="http://example.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 常用断言测试函数</title>
    <link href="http://example.com/2017/03/13/iOS%20%E5%B8%B8%E7%94%A8%E6%96%AD%E8%A8%80%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2017/03/13/iOS%20%E5%B8%B8%E7%94%A8%E6%96%AD%E8%A8%80%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/</id>
    <published>2017-03-13T15:38:22.000Z</published>
    <updated>2020-09-26T14:06:34.345Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">XCTFail(format…) 生成一个失败的测试； </span><br><span class="line"></span><br><span class="line">XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过； </span><br><span class="line"></span><br><span class="line">XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</span><br><span class="line"></span><br><span class="line">XCTAssert(expression, format...)当expression求值为TRUE时通过； </span><br><span class="line"></span><br><span class="line">XCTAssertTrue(expression, format...)当expression求值为TRUE时通过； </span><br><span class="line"></span><br><span class="line">XCTAssertFalse(expression, format...)当expression求值为False时通过； </span><br><span class="line"></span><br><span class="line">XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</span><br><span class="line"></span><br><span class="line">XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；</span><br><span class="line"></span><br><span class="line">XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）； </span><br><span class="line"></span><br><span class="line">XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class="line"></span><br><span class="line">XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+&#x2F;-accuracy）以内相等时通过测试； </span><br><span class="line"></span><br><span class="line">XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试； </span><br><span class="line"></span><br><span class="line">XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过； </span><br><span class="line"></span><br><span class="line">XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过； </span><br><span class="line"></span><br><span class="line">XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</span><br><span class="line"></span><br><span class="line">XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过； </span><br><span class="line"></span><br><span class="line">XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="测试" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="断言函数" scheme="http://example.com/tags/%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS NSDate 相关知识整理</title>
    <link href="http://example.com/2017/03/05/iOS%20NSDate%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2017/03/05/iOS%20NSDate%20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2017-03-05T14:03:56.000Z</published>
    <updated>2020-09-26T14:04:40.940Z</updated>
    
    <content type="html"><![CDATA[<p>　　项目最近用到一些关于 NSDate 的相关知识，特此记录。需要用的朋友可以创建一个类目，把需要用到的方法复制过去就行。</p><p>######目录<br> 1.是否为今天<br> 2.是否为昨天<br> 3.根据时间戳获取时间<br> 4.根据时间获取时间戳<br> 5.获取当前时间的时间戳<br> 6.计算两个日期间隔天数</p><a id="more"></a><p> 7.获取当前是星期几<br> 8.获取当前是几月几日<br> 9.计算时间差<br> 10.字符串转日期格式<br> 11.将世界时间转化为中国区时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 是否为今天</span><br><span class="line">- (BOOL)isToday&#123;</span><br><span class="line">    NSCalendar *cal &#x3D; [NSCalendar currentCalendar];</span><br><span class="line">    NSDateComponents *components &#x3D; [cal components:(NSCalendarUnitEra|NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:[NSDate date]];</span><br><span class="line">    NSDate *today &#x3D; [cal dateFromComponents:components];</span><br><span class="line">    </span><br><span class="line">    components &#x3D; [cal components:(NSCalendarUnitEra|NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:self];</span><br><span class="line">    NSDate *otherDate &#x3D; [cal dateFromComponents:components];</span><br><span class="line">    </span><br><span class="line">    if([today isEqualToDate:otherDate])&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 是否为昨天</span><br><span class="line">- (BOOL)isYesterday&#123;</span><br><span class="line">    NSCalendar *cal &#x3D; [NSCalendar currentCalendar];</span><br><span class="line">    NSDateComponents *components &#x3D; [cal components:(NSCalendarUnitEra|NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:[NSDate date]];</span><br><span class="line">    NSDate *today &#x3D; [cal dateFromComponents:components];</span><br><span class="line">    NSDate *yesterday &#x3D; [today dateByAddingTimeInterval: -kDayTimeInterval];</span><br><span class="line">    </span><br><span class="line">    components &#x3D; [cal components:(NSCalendarUnitEra|NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:self];</span><br><span class="line">    NSDate *otherDate &#x3D; [cal dateFromComponents:components];</span><br><span class="line">    </span><br><span class="line">    if([yesterday isEqualToDate:otherDate])&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据时间戳获取时间</span><br><span class="line">+ (NSString *)timeWithTimeStampString:(NSString *)timeStamp&#123;</span><br><span class="line">    &#x2F;&#x2F; 格式化时间</span><br><span class="line">    NSDateFormatter* formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;Asia&#x2F;Beijing&quot;];</span><br><span class="line">    [formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class="line">    [formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class="line">    [formatter setDateFormat:@&quot;yyyy-MM-dd&quot;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 毫秒值转化为秒</span><br><span class="line">    NSDate* date &#x3D; [NSDate dateWithTimeIntervalSince1970:[timeStamp doubleValue]&#x2F; 1000.0];</span><br><span class="line">    NSString* dateString &#x3D; [formatter stringFromDate:date];</span><br><span class="line">    return dateString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据时间获取时间戳</span><br><span class="line">+ (NSString *)timeStampWithDade:(NSDate *)date&#123;</span><br><span class="line">    NSTimeInterval a&#x3D;[date timeIntervalSince1970]*1000; &#x2F;&#x2F; *1000 是精确到毫秒，不乘就是精确到秒</span><br><span class="line">    NSString *timeString &#x3D; [NSString stringWithFormat:@&quot;%.0f&quot;, a]; &#x2F;&#x2F;转为字符型</span><br><span class="line">    return timeString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前时间的时间戳</span><br><span class="line">+ (NSInteger)getNowTimestamp&#123;</span><br><span class="line">    NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    [formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class="line">    [formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class="line">    [formatter setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; &#x2F;&#x2F;</span><br><span class="line">    </span><br><span class="line">    NSTimeZone* timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;Asia&#x2F;Beijing&quot;];</span><br><span class="line">    [formatter setTimeZone:timeZone];</span><br><span class="line">    </span><br><span class="line">    NSDate *datenow &#x3D; [NSDate date];&#x2F;&#x2F;现在时间</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;时间转时间戳的方法:</span><br><span class="line">    NSInteger timeSp &#x3D; [[NSNumber numberWithDouble:[datenow timeIntervalSince1970]] integerValue];</span><br><span class="line">    </span><br><span class="line">    return timeSp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算两个日期间隔天数</span><br><span class="line">+ (NSInteger)getDaysFrom:(NSString *)beginDate To:(NSString *)endDate&#123;</span><br><span class="line">    </span><br><span class="line">    NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.dateFormat &#x3D; @&quot;yyyy-MM-dd&quot;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将字符串日期 转换为 NSDate 类型,并去掉时分秒信息</span><br><span class="line">    NSDate *fromDate &#x3D; [NSDate worldTimeToChina:[formatter dateFromString:[beginDate substringToIndex:10]]];</span><br><span class="line">    NSDate *toDate &#x3D; [NSDate worldTimeToChina:[formatter dateFromString:[endDate substringToIndex:10]]];</span><br><span class="line"></span><br><span class="line">    NSTimeInterval time &#x3D; [toDate timeIntervalSinceDate:fromDate];</span><br><span class="line">    NSInteger days &#x3D; ((int)time) &#x2F; (3600 * 24);</span><br><span class="line"></span><br><span class="line">    return days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前是星期几</span><br><span class="line">+ (NSInteger)getNowWeekday &#123;</span><br><span class="line">    </span><br><span class="line">    NSCalendar *calendar &#x3D; [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">    NSDateComponents *comps &#x3D; [[NSDateComponents alloc] init];</span><br><span class="line">    NSInteger unitFlags &#x3D; NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitWeekday |</span><br><span class="line">    NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;</span><br><span class="line">    NSDate *now &#x3D; [NSDate date];</span><br><span class="line">    &#x2F;&#x2F; 在真机上需要设置区域，才能正确获取本地日期，中国区代码：zh_CN</span><br><span class="line">    calendar.locale &#x3D; [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];</span><br><span class="line">    comps &#x3D; [calendar components:unitFlags fromDate:now];</span><br><span class="line">    </span><br><span class="line">    return [comps weekday];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前是几月几日</span><br><span class="line">+ (NSString *)getTodayStr&#123;</span><br><span class="line">    NSCalendar *cal &#x3D; [NSCalendar currentCalendar];</span><br><span class="line">    </span><br><span class="line">    NSDateComponents *components &#x3D; [cal components:(NSCalendarUnitEra|NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:[NSDate date]];</span><br><span class="line">    NSDate *today &#x3D; [cal dateFromComponents:components];</span><br><span class="line">    </span><br><span class="line">    NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.dateFormat &#x3D; @&quot;MM月dd日&quot;;</span><br><span class="line">    return [formatter stringFromDate:today];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算时间差</span><br><span class="line">+ (NSTimeInterval)timeInterValWithDate:(NSString *)featureDate&#123;</span><br><span class="line">    </span><br><span class="line">    NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 设置日期格式，可以根据自己的需求随时调整，否则计算的结果为 nil</span><br><span class="line">    formatter.locale &#x3D; [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];</span><br><span class="line">    formatter.dateFormat &#x3D; @&quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">    &#x2F;&#x2F; 将字符串日期 转换为 NSDate 类型</span><br><span class="line">    NSDate *endDate &#x3D; [formatter dateFromString:featureDate];</span><br><span class="line">    </span><br><span class="line">    return [endDate timeIntervalSinceDate:[NSDate new]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串转日期格式</span><br><span class="line">+ (NSDate *)stringToDate:(NSString *)dateString withDateFormat:(NSString *)format&#123;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    [dateFormatter setDateFormat:format];</span><br><span class="line">    </span><br><span class="line">    NSDate *date &#x3D; [dateFormatter dateFromString:dateString];</span><br><span class="line">    return date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将世界时间转化为中国区时间</span><br><span class="line">+ (NSDate *)worldTimeToChina:(NSDate *)date&#123;</span><br><span class="line">    NSTimeZone *timeZone &#x3D; [NSTimeZone systemTimeZone];</span><br><span class="line">    NSInteger interval &#x3D; [timeZone secondsFromGMTForDate:date];</span><br><span class="line">    NSDate *localeDate &#x3D; [date  dateByAddingTimeInterval:interval];</span><br><span class="line">    return localeDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　项目最近用到一些关于 NSDate 的相关知识，特此记录。需要用的朋友可以创建一个类目，把需要用到的方法复制过去就行。&lt;/p&gt;
&lt;p&gt;######目录&lt;br&gt; 1.是否为今天&lt;br&gt; 2.是否为昨天&lt;br&gt; 3.根据时间戳获取时间&lt;br&gt; 4.根据时间获取时间戳&lt;br&gt; 5.获取当前时间的时间戳&lt;br&gt; 6.计算两个日期间隔天数&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="NSDate" scheme="http://example.com/tags/NSDate/"/>
    
  </entry>
  
  <entry>
    <title>iOS iCarousel实现视图水平滑动（中间放大，两边缩小）选择影片效果</title>
    <link href="http://example.com/2017/02/19/iOS%20iCarousel%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E6%B0%B4%E5%B9%B3%E6%BB%91%E5%8A%A8%EF%BC%88%E4%B8%AD%E9%97%B4%E6%94%BE%E5%A4%A7%EF%BC%8C%E4%B8%A4%E8%BE%B9%E7%BC%A9%E5%B0%8F%EF%BC%89%E9%80%89%E6%8B%A9%E5%BD%B1%E7%89%87%E6%95%88%E6%9E%9C/"/>
    <id>http://example.com/2017/02/19/iOS%20iCarousel%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E6%B0%B4%E5%B9%B3%E6%BB%91%E5%8A%A8%EF%BC%88%E4%B8%AD%E9%97%B4%E6%94%BE%E5%A4%A7%EF%BC%8C%E4%B8%A4%E8%BE%B9%E7%BC%A9%E5%B0%8F%EF%BC%89%E9%80%89%E6%8B%A9%E5%BD%B1%E7%89%87%E6%95%88%E6%9E%9C/</id>
    <published>2017-02-19T15:17:28.000Z</published>
    <updated>2020-09-26T14:04:55.593Z</updated>
    
    <content type="html"><![CDATA[<p>使用到的第三方库：<a href="https://github.com/nicklockwood/iCarousel">iCarousel</a>。</p><p>使用：iCarousel使用方式与UITableView相似，具体看代码。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;iCarousel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;iCarouselDelegate,iCarouselDataSource&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) iCarousel *filmCarousel;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *filmImageNameArr;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *filmNameArr;</span><br><span class="line">@property (nonatomic, strong) UIView *selectView;</span><br><span class="line">@property (nonatomic, strong) UILabel *filmNameLab;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:self.filmCarousel];</span><br><span class="line">    </span><br><span class="line">    self.filmNameLab &#x3D; [[UILabel alloc]initWithFrame:CGRectMake(0, CGRectGetMaxY(self.filmCarousel.frame), self.view.frame.size.width, 44)];</span><br><span class="line">    self.filmNameLab.font &#x3D; [UIFont systemFontOfSize:20];</span><br><span class="line">    self.filmNameLab.textAlignment &#x3D; NSTextAlignmentCenter;</span><br><span class="line">    [self.view addSubview:self.filmNameLab];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - iCarouselDataSource</span><br><span class="line">-(NSInteger)numberOfItemsInCarousel:(iCarousel *)carousel&#123;</span><br><span class="line">    return self.filmImageNameArr.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(UIView *)carousel:(iCarousel *)carousel viewForItemAtIndex:(NSInteger)index reusingView:(UIView *)view&#123;</span><br><span class="line">    </span><br><span class="line">    UIImage *image &#x3D; [UIImage imageNamed:[self.filmImageNameArr objectAtIndex:index]];</span><br><span class="line">    if (view &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        view &#x3D; [[UIView alloc] initWithFrame:CGRectMake(0, 0, 80, 120)];</span><br><span class="line">        view.backgroundColor &#x3D; [UIColor clearColor];</span><br><span class="line">        </span><br><span class="line">        UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(2, 2, 76, 116)];</span><br><span class="line">        imageView.tag &#x3D; 1000+index;</span><br><span class="line">        [view addSubview:imageView];</span><br><span class="line">    &#125;</span><br><span class="line">    UIImageView *imageView &#x3D; [view viewWithTag:1000+index];</span><br><span class="line">    imageView.image &#x3D; image;</span><br><span class="line">    </span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - iCarouselDelegate</span><br><span class="line">- (void)carouselDidEndScrollingAnimation:(iCarousel *)carousel&#123;</span><br><span class="line">    NSLog(@&quot;___1 %lu&quot;,carousel.currentItemIndex);</span><br><span class="line">    UIView *view &#x3D; carousel.currentItemView;</span><br><span class="line">    view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    self.selectView &#x3D; view;</span><br><span class="line">    self.filmNameLab.text &#x3D; self.filmNameArr[carousel.currentItemIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)carouselDidScroll:(iCarousel *)carousel&#123;</span><br><span class="line">    NSLog(@&quot;___2 %lu&quot;,carousel.currentItemIndex);</span><br><span class="line">    if (self.selectView !&#x3D; carousel.currentItemView) &#123;</span><br><span class="line">        self.selectView.backgroundColor &#x3D; [UIColor clearColor];</span><br><span class="line">        UIView *view &#x3D; carousel.currentItemView;</span><br><span class="line">        view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">        </span><br><span class="line">        self.filmNameLab.text &#x3D; self.filmNameArr[carousel.currentItemIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)carouselCurrentItemIndexDidChange:(iCarousel *)carousel&#123;</span><br><span class="line">    NSLog(@&quot;___3 %lu&quot;,carousel.currentItemIndex);</span><br><span class="line">    self.selectView &#x3D; carousel.currentItemView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(CATransform3D)carousel:(iCarousel *)carousel itemTransformForOffset:(CGFloat)offset baseTransform:(CATransform3D)transform&#123;</span><br><span class="line">    static CGFloat max_sacle &#x3D; 1.0f;</span><br><span class="line">    static CGFloat min_scale &#x3D; 0.8f;</span><br><span class="line">    if (offset &lt;&#x3D; 1 &amp;&amp; offset &gt;&#x3D; -1) &#123;</span><br><span class="line">        float tempScale &#x3D; offset &lt; 0 ? 1+offset : 1-offset;</span><br><span class="line">        float slope &#x3D; (max_sacle - min_scale) &#x2F; 1;</span><br><span class="line">        </span><br><span class="line">        CGFloat scale &#x3D; min_scale + slope*tempScale;</span><br><span class="line">        transform &#x3D; CATransform3DScale(transform, scale, scale, 1);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        transform &#x3D; CATransform3DScale(transform, min_scale, min_scale, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return CATransform3DTranslate(transform, offset * self.filmCarousel.itemWidth * 1.4, 0.0, 0.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - LazyLoad</span><br><span class="line">-(iCarousel *)filmCarousel&#123;</span><br><span class="line">    if (_filmCarousel &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        _filmCarousel &#x3D; [[iCarousel alloc] initWithFrame:CGRectMake(0, self.view.frame.size.height &#x2F; 2 - 100, self.view.frame.size.width, 150)];</span><br><span class="line">        _filmCarousel.delegate &#x3D; self;</span><br><span class="line">        _filmCarousel.dataSource &#x3D; self;</span><br><span class="line">        _filmCarousel.backgroundColor &#x3D; [UIColor lightGrayColor];</span><br><span class="line">        _filmCarousel.bounces &#x3D; NO;</span><br><span class="line">        _filmCarousel.pagingEnabled &#x3D; YES;</span><br><span class="line">        _filmCarousel.type &#x3D; iCarouselTypeCustom;</span><br><span class="line">    &#125;</span><br><span class="line">    return _filmCarousel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)filmImageNameArr&#123;</span><br><span class="line">    if (!_filmImageNameArr) &#123;</span><br><span class="line">        _filmImageNameArr &#x3D; [NSMutableArray array];</span><br><span class="line">        for (int i &#x3D; 1; i&lt; 6; i++) &#123;</span><br><span class="line">            [_filmImageNameArr addObject:[NSString stringWithFormat:@&quot;defaultFilm%d&quot;,i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _filmImageNameArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)filmNameArr&#123;</span><br><span class="line">    if (!_filmNameArr) &#123;</span><br><span class="line">        _filmNameArr &#x3D; [NSMutableArray array];</span><br><span class="line">        for (int i &#x3D; 1; i&lt; 6; i++) &#123;</span><br><span class="line">            [_filmNameArr addObject:[NSString stringWithFormat:@&quot;film %d&quot;,i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _filmNameArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-e5055e312bb18112.gif?imageMogr2/auto-orient/strip" alt="运行效果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用到的第三方库：&lt;a href=&quot;https://github.com/nicklockwood/iCarousel&quot;&gt;iCarousel&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用：iCarousel使用方式与UITableView相似，具体看代码。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="iCarousel" scheme="http://example.com/tags/iCarousel/"/>
    
    <category term="第三方" scheme="http://example.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>iOS 使用自带视频播放器播放视频</title>
    <link href="http://example.com/2017/02/12/iOS%20%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%20/"/>
    <id>http://example.com/2017/02/12/iOS%20%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%20/</id>
    <published>2017-02-12T13:15:34.000Z</published>
    <updated>2020-09-26T14:00:02.326Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;AVFoundation&#x2F;AVFoundation.h&gt;</span><br><span class="line">#import &lt;AVKit&#x2F;AVPlayerViewController.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) AVPlayerViewController *moviePlayerView;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSURL *url&#x3D; [NSURL URLWithString:@&quot;test.mp4&quot;];</span><br><span class="line"></span><br><span class="line">    self.moviePlayerView &#x3D; [[AVPlayerViewController alloc] init];</span><br><span class="line"></span><br><span class="line">    AVPlayer *player &#x3D; [AVPlayer playerWithURL:url];</span><br><span class="line"></span><br><span class="line">    self.moviePlayerView.player &#x3D; player;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置界面缩放比例</span><br><span class="line">    self.moviePlayerView.videoGravity &#x3D; AVLayerVideoGravityResizeAspect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)playAction:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">    [self presentViewController:self.moviePlayerView animated:YES completion:NULL];</span><br><span class="line"></span><br><span class="line">    [self.moviePlayerView.player play];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="Video" scheme="http://example.com/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>iOS UIButton 的 titleLabel</title>
    <link href="http://example.com/2017/02/05/iOS%20UIButton%20%E7%9A%84%20titleLabel/"/>
    <id>http://example.com/2017/02/05/iOS%20UIButton%20%E7%9A%84%20titleLabel/</id>
    <published>2017-02-05T15:58:35.000Z</published>
    <updated>2020-09-26T14:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，有时会克制不住的写出下面这行代码。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.titleLabel.text &#x3D; @&quot;不显示&quot;;</span><br></pre></td></tr></table></figure><p>然后运行，不出意外的话，是不会显示的。<br>使用 po 命令来查看一下titleLabel。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-c9c4c9c0994b8c3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="btn.titleLabel"></p><p>可以看出默认的titleLabel是没有设置frame的，且hidden = YES；<br>然后我们设置下titleLabel的frame及hidden</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.titleLabel.text &#x3D; @&quot;不显示&quot;;</span><br><span class="line">btn.titleLabel.frame &#x3D; CGRectMake(0, 0, 100, 44);</span><br><span class="line">btn.titleLabel.hidden &#x3D; NO;</span><br></pre></td></tr></table></figure><p>发现还是不会显示。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-28f86ec49b7ae8dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="btn.titleLabel"></p><p>可以看出frame已经设置了，但是hidden属性并没有改变。</p><p>从<a href="http://blog.csdn.net/u012894631/article/details/17381067">这篇</a>文章可知，按钮上显示的是CurrnetTitle，而不是titlelabel。而<code>btn.titleLabel.text = @&quot;不显示&quot;;</code>这行代码并不会改变CurrnetTitle。</p><p><a href="http://stackoverflow.com/questions/16656964/uibutton-titlelabel-not-displaying">stackoverflow</a>上有关于这个问题的描述。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-7ebaf2f52bd51bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/750" alt="stackoverflow"></p><p>也就是说，在赋值titleLabel的时候，需要为其指定一个状态。<br>正确的写法为：<br><code>[btn setTitle:@&quot;显示&quot; forState:(UIControlStateNormal)];</code></p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-fe386cada9d6c1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="指定状态之后的titleLabel"></p><p>这回终于可以显示了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发中，有时会克制不住的写出下面这行代码。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="UIButton" scheme="http://example.com/tags/UIButton/"/>
    
  </entry>
  
  <entry>
    <title>iOS 定位(CoreLocation)</title>
    <link href="http://example.com/2017/01/29/iOS%20%E5%AE%9A%E4%BD%8D(CoreLocation)/"/>
    <id>http://example.com/2017/01/29/iOS%20%E5%AE%9A%E4%BD%8D(CoreLocation)/</id>
    <published>2017-01-29T14:32:17.000Z</published>
    <updated>2020-09-26T14:01:12.815Z</updated>
    
    <content type="html"><![CDATA[<p>　　在很多LBS的应用中我们都可以看到定位的使用。如下面美团外卖选择城市的页面。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-c286bfb2a7eacfe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/250" alt="美团外卖选择城市页"></p><p>　　下面我们就实现一个定位Demo，并将获取到的定位城市展示到页面上。</p><p>　　iOS系统已经封装了一个用于定位的类库CoreLocation，我们只需要将其头文件导入。要想使用定位服务，首先需要实例化一个CLLocationManager对象并设置Delegate。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)initLocationManager&#123;</span><br><span class="line">    self.locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class="line">    self.locationManager.delegate &#x3D; self;</span><br><span class="line">    self.locationManager.desiredAccuracy&#x3D;kCLLocationAccuracyBest;</span><br><span class="line">    self.locationManager.distanceFilter&#x3D;10;</span><br><span class="line">    </span><br><span class="line">    if ([[[UIDevice currentDevice] systemVersion] floatValue]&gt;&#x3D;8) &#123;</span><br><span class="line">        [self.locationManager requestWhenInUseAuthorization];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.locationManager startUpdatingLocation];&#x2F;&#x2F;开启定位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - CLLocationManagerDelegate  </span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations&#123;</span><br><span class="line">    CLLocation *currLocation&#x3D;[locations lastObject];</span><br><span class="line">    NSLog(@&quot;latitude---%f, longitude---%f&quot;,currLocation.coordinate.latitude,currLocation.coordinate.longitude);</span><br><span class="line">    </span><br><span class="line">    CLGeocoder *clGeoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class="line">    [clGeoCoder reverseGeocodeLocation:currLocation completionHandler: ^(NSArray *placemarks,NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;--array--%d---error--%@&quot;,(int)placemarks.count,error);</span><br><span class="line">        </span><br><span class="line">        if (placemarks.count &gt; 0) &#123;</span><br><span class="line">            CLPlacemark *placemark &#x3D; [placemarks objectAtIndex:0];</span><br><span class="line">            NSString *city &#x3D; placemark.administrativeArea;</span><br><span class="line">            NSLog(@&quot;位于:%@&quot;,city);</span><br><span class="line">            NSLog(@&quot;%@&quot;,placemark.addressDictionary[@&quot;Name&quot;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager</span><br><span class="line">       didFailWithError:(NSError *)error&#123;</span><br><span class="line">    if ([error code]&#x3D;&#x3D;kCLErrorDenied) &#123;</span><br><span class="line">        NSLog(@&quot;访问被拒绝&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if ([error code]&#x3D;&#x3D;kCLErrorLocationUnknown) &#123;</span><br><span class="line">        NSLog(@&quot;无法获取位置信息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　在很多LBS的应用中我们都可以看到定位的使用。如下面美团外卖选择城市的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1690826-c286bfb2a7eacfe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/250&quot; alt=&quot;美团外卖选择城市页&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们就实现一个定位Demo，并将获取到的定位城市展示到页面上。&lt;/p&gt;
&lt;p&gt;　　iOS系统已经封装了一个用于定位的类库CoreLocation，我们只需要将其头文件导入。要想使用定位服务，首先需要实例化一个CLLocationManager对象并设置Delegate。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="定位" scheme="http://example.com/tags/%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>iOS OC编码规范指南</title>
    <link href="http://example.com/2017/01/23/iOS%20OC%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2017/01/23/iOS%20OC%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</id>
    <published>2017-01-22T16:00:45.000Z</published>
    <updated>2020-09-26T14:04:33.345Z</updated>
    
    <content type="html"><![CDATA[<p>说明：规范的目的是提高效率，所使用的规范应该是适应当前团队的。<br>####项目工程结构<br>#####代码结构</p><ul><li>实现文件中的代码结构，提倡以下约定：<ul><li>用#pragma mark -将函数或方法按功能进行分组;</li><li>分组之间空2行,方法之间空1行;</li><li>delgate或协议相关方法放到一般内容之后。</li></ul></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Lifecycle (生命周期)</span><br><span class="line">- (void)dealloc &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Private (私有方法,比如初始控件设置方法&#x2F;类内部业务处理方法)</span><br><span class="line">- (CGFloat)setupTableView &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Public (对外公开方法)</span><br><span class="line">- (CGFloat)reloadAllData &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Network (加载网络数据)</span><br><span class="line">- (void)loadMoreData &#123;&#125;</span><br><span class="line">- (void)loadNewData &#123;&#125;</span><br><span class="line">- (void)loadOtherData &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Property Setter&#x2F;Getter (成员属性的setter和getter方法)</span><br><span class="line">- (void)setCustomProperty:(id)value &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (id)customProperty &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Events (UIControl响应函数,如按钮点击事件)</span><br><span class="line">- (void)saveButtonClick:(UIButton *)saveButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - KVO&#x2F;Notification (KVO&#x2F;通知响应函数)</span><br><span class="line">- (void)dataSourceRefreshNotification:(NSNotification *)notification &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSString*, id&gt; *)change context:(nullable void *)context &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Protocol&#x2F;Delegate 如UITableViewDataSource&#x2F;UITableViewDelegate (协议和代理)</span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - LazyLoad (懒加载)</span><br><span class="line">- (UILabel *)nameLabel &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Other (其他)</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;&#125;</span><br><span class="line">- (NSString *)description &#123;&#125;</span><br></pre></td></tr></table></figure><p>####项目Xode相关配置<br>#####代码缩进配置</p><ul><li>只用空格缩进，1个TAB = 4个空格字符;</li><li>在XCode-&gt;Preferences-&gt;Text Editing-&gt;Indentation中进行如下设置(ps. 设置成4个，是因为Xcode的默认缩进是4个空格)。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1690826-0afee45b3c4104f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码格式化配置"></p><p>####代码行号显示配置<br>#####Xcode行号显示配置</p><ul><li>勾选上XCode-&gt;Preferences-&gt;Text Editing-&gt;Editing中的Line numbers，开启行号提示。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1690826-405c2e7d24a8b7c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码行号显示配置"></p><p>#####项目编码建议</p><ul><li>建议：每行代码的长度最多不超过120个字符;<ul><li>勾选XCode-&gt;Preferences-&gt;Text Editing-&gt;Editing，并将长度设置成120个字符来打开行宽指示。设置成功时Xcode会出现一条竖线! (可选配置)</li></ul></li><li>建议：为了简洁和便于阅读,尝试将单个函数或方法的实现代码控制在50行内;单个实现文件里的代码行数控制在500～600行内;</li><li>建议：为了简洁和便于阅读,请尝试将单个函数或方法的实现代码控制在50行内;当接近或超过800行时，就应当开始考虑分割实现文件了。</li></ul><p>####注释<br>#####方法注释</p><ul><li>方法注释规则<ul><li>注释应该尽量保持简洁，代码应该尽量达到能自我解释的程度;</li><li>注释必须和代码保持同步。不要出现代码修改了，注释不更新的情况;</li><li>Xcode注释,公开方法需尽量注释清楚;如果公开方法有带参数,可按需对参数进行说明;</li><li>其他方法可使用 // 方法描述 或 VVDocumenter-Xcode 注释;</li><li>方法内部行注释需对齐;</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .m文件</span><br><span class="line">&#x2F;&#x2F; 按钮点击事件处理 (非对外公开的方法)</span><br><span class="line">- (void)saveButtonClick:(UIButton *)saveButton &#123;</span><br><span class="line">    NSLog(@&quot;Hello Liwx&quot;);               &#x2F;&#x2F; 打印日志</span><br><span class="line">    NSLog(@&quot;Hello Liwx&quot;);               &#x2F;&#x2F; 打印日志</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 刷新全部数据 (对外公开的方法)*&#x2F;</span><br><span class="line">- (void)reloadAllData &#123;</span><br><span class="line">    &#x2F;&#x2F;Do Something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .h文件</span><br><span class="line">&#x2F;** 刷新全部数据 (对外公开的方法)*&#x2F;</span><br><span class="line">- (void)reloadAllData;</span><br></pre></td></tr></table></figure><p>#####属性注释</p><ul><li>建议外部属性注释建议使用/** 属性描述 */注释, 因为Xcode对此类注释有提示功能,便于开发人员在编码时能更快的了解该属性的作用;</li><li>建议属性与@interface … @end之间各空1行;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface UserInfo : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;** 用户名 *&#x2F;</span><br><span class="line">@property (nonatomic,  copy) NSString *userName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-9b341a1f2576c536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外部属性注释提示"></p><ul><li>私有属性注释可使用// 属性描述或/** 属性描述 */注释。</li></ul><p>####命名与编码规范<br>#####类名命名规则</p><ul><li>类名命名规则<ul><li>类名、类别名字及协议名字，都采用大驼峰式命名规则；</li><li>文件名要能反映出它所包含的类的名称；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：NSString.h 和 NSString.m 包含了NSString类的定义和实现</span><br></pre></td></tr></table></figure></li><li>Category的文件名要包含它所扩展的那个类的名称，并且类别名称要尽量能够描述它的功能;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImage+Resize.h 或 UIImage+TintColor.h</span><br></pre></td></tr></table></figure></li><li>在面向特定应用的代码中，类名尽量避免使用前缀，每个类都使用相同的前缀会影响可读性（面向特定应用的代码，指那些只会在一个项目中使用的代码，不会被用于其他项目中的代码）；</li><li>在面向多应用的代码中，类名要使用前缀，防止命名冲突（面向多应用的代码，指那些会被多个项目共同使用的代码）；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如CRKit这个类库中，使用了CR前缀。</span><br></pre></td></tr></table></figure></li><li>建议：前缀至少使用三个字母（此条是为了减少命名冲突。但鉴于目前流行前缀大多都是两个字母，所以此条不做强制要求）。</li></ul></li></ul><p>#####协议编码规则</p><ul><li>协议声明或定义中，类型标识符、协议名称、尖括号之间不留空格;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 协议声明协议名称、尖括号之间不留空格</span><br><span class="line">@protocol UITableViewDelegate&lt;NSObject, UIScrollViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F; 定义属性遵守协议,不留空格</span><br><span class="line">@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>#####控件/控制器定义命名规则</p><ul><li>控件命名尽量使用控件全称命名,不建议使用缩写;</li><li>命名规则: [功能(name)]+[控件名(Label)]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建议使用控件全称命名</span><br><span class="line">&#x2F;** 名称Label *&#x2F;</span><br><span class="line">@property (nonatomic, weak) UILabel *nameLabel;</span><br><span class="line">&#x2F;** 保存Button *&#x2F;</span><br><span class="line">@property (nonatomic, weak) UIButton *saveButton;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不建议控件名使用缩写</span><br><span class="line">&#x2F;** 名称Label *&#x2F;</span><br><span class="line">@property (nonatomic, weak) UILabel *nameLbl;</span><br><span class="line">&#x2F;** 保存Button *&#x2F;</span><br><span class="line">@property (nonatomic, weak) UIButton *saveBtn;</span><br></pre></td></tr></table></figure><ul><li>定义或声明类时如果名称过长采用后缀缩写;注意大小写;</li><li>如控制器ViewController可缩写为Vc;</li><li>TableViewCell可缩写为TvCell;</li><li>CollectionViewCell可缩写为CvCell;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TableViewCell后缀缩写为TvCell</span><br><span class="line">TopicTableViewCell *topicTvCell &#x3D; nil;</span><br><span class="line">&#x2F;&#x2F; CollectionViewCell后缀缩写为CvCell</span><br><span class="line">ItemCollectionViewCell *itemCvCell &#x3D; nil;</span><br><span class="line">&#x2F;&#x2F; ViewController可缩写为Vc</span><br><span class="line">HomeViewController *homeVc &#x3D; nil;</span><br></pre></td></tr></table></figure><p>####方法<br>#####方法名和参数命名规则</p><ul><li>方法名和参数名都采用小驼峰式命名规则;<ul><li>如：- (BOOL)isFileExistedAtPath:(NSString *)filePath;</li></ul></li></ul><ul><li>方法名可以使⽤用情态动词( can , should , will 等)来提⾼高清晰性,但不要使⽤用 do 或 does;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">- (BOOL)canHide;</span><br><span class="line">- (BOOL)shouldRefreshData;</span><br><span class="line">- (void)willChangeData;</span><br></pre></td></tr></table></figure><p>####方法声明和编码规范</p><ul><li>方法声明中，-/+和返回值类型之间要空1个空格，方法名和参数类型之间以及参数类型和参数名之间不留空格;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initwithTitle:(NSString *)title;    &#x2F;&#x2F; 正确</span><br><span class="line"></span><br><span class="line">-(instancetype)initwithTitle:(NSString *)title;     &#x2F;&#x2F; 错误</span><br><span class="line">- (instancetype) initwithTitle:(NSString *)title;   &#x2F;&#x2F; 错误</span><br><span class="line">- (instancetype)initwithTitle: (NSString *)title;   &#x2F;&#x2F; 错误</span><br><span class="line">- (instancetype)initwithTitle:(NSString *) title;   &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure><ul><li><p>方法名和参数名应该尽量读起来像一句话。<br>如：convertPoint:fromRect:<br>或者 replaceCharactersInRange:withString:</p></li><li><p>当各个参数是接收者的某个属性时，方法名中不要用”and”来连接;</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil andBundle:(NSBundle *)nibBundleOrNil;</span><br></pre></td></tr></table></figure><ul><li>方法名之后空1格,紧随左大括号{,无需换号;但是右大括号}必须另取一行;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)setupTableView &#123;</span><br><span class="line">    &#x2F;&#x2F; Do Something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用父类方法编码规则<br>重载父类方法时，遇到必须调用父类方法时。调用super的代码和重载的代码之间留一行空行。将super方法的调用和重载代码区隔开来;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do Something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####函数</p><ul><li>函数指纯C函数，这里提倡与苹果风格类似的约定。<ul><li>函数名采用大驼峰式命名方式;</li><li>参数名采用小驼峰式命名方式;</li><li>如果函数和某个特定类型相关，那么函数名前缀要和类型前缀一样。<br><code>如CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)等。</code></li></ul></li></ul><p>####变量<br>#####成员属性编码规则</p><ul><li>属性名和变量名都采用小驼峰式命名规则;</li><li>禁止使用匈牙利标记法或含糊不清的缩写单词来命名变量;</li><li>指针符号 “*” 靠近变量名字。(常量定义除外)</li><li>property属性括号两边各空1格, 属性关键字以逗号加空格隔开</li><li>除了xib拖控件的方式除外,nonatomic需放在最前面, srong,weak,assign,copy应放在nonatomic后面;</li><li>成员变量和局部变量声明Demo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 成员变量声明</span><br><span class="line">&#x2F;** 标题Label (正确) *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *titleLabel;</span><br><span class="line"></span><br><span class="line">&#x2F;** 标题Label (错误) *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *titleLbl;</span><br><span class="line">&#x2F;** 标题Label (错误) *&#x2F;</span><br><span class="line">@property(nonatomic, copy) NSString *titleLabel;</span><br><span class="line">&#x2F;** 标题Label (错误) *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSString *titleLabel;</span><br><span class="line">&#x2F;** 标题Label (错误) *&#x2F;</span><br><span class="line">@property (copy, nonatomic) NSString *titleLabel;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 局部变量声明</span><br><span class="line">NSString *titleLabel &#x3D; nil;     &#x2F;&#x2F;  正确</span><br><span class="line"></span><br><span class="line">NSString* titleLabel &#x3D; nil;     &#x2F;&#x2F;  错误</span><br><span class="line">NSString * titleLabel &#x3D; nil;    &#x2F;&#x2F;  错误</span><br><span class="line">NSString*titleLabel &#x3D; nil;      &#x2F;&#x2F;  错误</span><br></pre></td></tr></table></figure><ul><li>使用property时，优先使用点语法;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 名称 *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问成员属性时,优先使用点语法</span><br><span class="line">self.name &#x3D; @&quot;Liwx&quot;;</span><br></pre></td></tr></table></figure><ul><li>赋值操作符 “=”两边各空1格;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.name &#x3D; @&quot;Liwx&quot;;    &#x2F;&#x2F; 正确</span><br><span class="line"></span><br><span class="line">self.name&#x3D; @&quot;Liwx&quot;;     &#x2F;&#x2F; 错误</span><br><span class="line">self.name&#x3D;@&quot;Liwx&quot;;      &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure><ul><li>如果使用property修饰的是属性BOOL值，建议为getter方法加上一个”is”开头的别名。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, getter &#x3D; isSelected) BOOL selected;</span><br></pre></td></tr></table></figure><ul><li>如果网络获取的属性数据为数值型的,则定义属性也应该为数值型;<br>如果是枚举类型,则应定义对应枚举类型;不应将数值型定义为NSString字符串类型;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">@property (copy,nonatomic) UserStatus *userStatus;</span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">@property (copy,nonatomic) NSString *userStatus;</span><br></pre></td></tr></table></figure><p>####常量<br>#####Foundation框架常量赋值规则</p><ul><li>为了提高代码简洁度,创建NSString, NSDictionary, NSArray, 以及NSNumber等常量时，使用Literals语法;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">NSArray *names &#x3D; @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</span><br><span class="line">NSDictionary *productManagers &#x3D; @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; </span><br><span class="line">NSNumber *shouldUseLiterals &#x3D; @YES; </span><br><span class="line">NSNumber *buildingZIPCode &#x3D; @10018; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">NSArray *names &#x3D; [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil]; </span><br><span class="line">NSDictionary *productManagers &#x3D; [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil]; </span><br><span class="line">NSNumber *shouldUseLiterals &#x3D; [NSNumber numberWithBool:YES]; </span><br><span class="line">NSNumber *zipCode &#x3D; [NSNumber numberWithInteger:10018];</span><br></pre></td></tr></table></figure><p>#####定义普通常量以字母k开头</p><ul><li>如果定义的常量是类,则格式为: [类名] +  [*] + [const] + [k+常量描述];</li><li>如果定义的常量属于基本数据类型, 则格式为: [基本数据类型] + [const] + [k+常量描述];</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通常量定义</span><br><span class="line">NSString * const kUserKey &#x3D; @&quot;kUserKey&quot;;</span><br><span class="line">CGFloat const kTopViewHeight &#x3D; 50;</span><br></pre></td></tr></table></figure><ul><li>只在某一个特定文件里面使用的常量，用static;<br>static关键字保证变量只有文件作用域，可以避免变量名重名造成的链接错误问题。<br>如: <code>static CGFloat const RWImageThumbnailHeight = 50.0;</code></li></ul><p>####枚举与宏定义<br>#####枚举编码规则</p><ul><li><p>定义枚举常量时，使用NS_ENUM或NS_OPTIONS;</p><p>  因为NS_ENUM和NS_OPTIONS都提供了类型检查;</p></li><li><p>定义枚举时,一定要注释,并且格式为: [枚举类型名(UITableViewStyle)] + [类型(Plain)];</p></li></ul><p>######NS_ENUM定义普通枚举</p><ul><li>使用NS_ENUM定义普通枚举Demo,建议枚举值 = 对应数值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用皮肤样式</span><br><span class="line">typedef NS_ENUM(NSInteger, AppStyle) &#123;</span><br><span class="line">    AppStyleLight &#x3D; 0,              &#x2F;&#x2F; 白天模式</span><br><span class="line">    AppStyleDark &#x3D; 1                &#x2F;&#x2F; 夜间模式</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>######NS_OPTIONS定义位枚举</p><ul><li>使用NS_OPTIONS定义位枚举</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class="line">    UIViewAutoresizingNone                 &#x3D; 0,         &#x2F;&#x2F; 注释</span><br><span class="line">    UIViewAutoresizingFlexibleLeftMargin   &#x3D; 1 &lt;&lt; 0,    &#x2F;&#x2F; 注释</span><br><span class="line">    UIViewAutoresizingFlexibleWidth        &#x3D; 1 &lt;&lt; 1,    &#x2F;&#x2F; 注释</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####通知和异常<br>#####通知NSNotification常量命名规则</p><ul><li><p>通知常量命名<br>格式: [相关联的类名字] + [Did | Will] + [独一无二的一段名称] + Notification</p><ul><li>建议:定义通知常量不采用宏定义的方法;</li><li>.h文件, 全局通知声明时需加上UIKIT_EXTERN关键字；</li><li>.m文件, 通知常量名和值必须保持一致。</li></ul></li><li><p>通知命名Demo</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .h文件</span><br><span class="line">&#x2F;&#x2F; 全局通知声明时需加上UIKIT_EXTERN关键字</span><br><span class="line">UIKIT_EXTERN NSString *const UIKeyboardDidChangeFrameNotification ;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .m文件, 通知常量名和值必须保持一致</span><br><span class="line">NSString *const UIKeyboardDidChangeFrameNotification &#x3D; @&quot;UIKeyboardDidChangeFrameNotification&quot;;</span><br></pre></td></tr></table></figure><p>#####异常命名规则</p><ul><li>异常名字的命名规则：[前缀] + [独一无二的一段名称] + Exception<br> 如：NSColorListIOException</li></ul><p>#####布尔值</p><ul><li>Objective-C的布尔值只使用YES和NO;</li><li>注意: true和false只能用于CoreFoundation，C或C++的代码中;</li><li>禁止将某个值或表达式的结果与YES进行比较</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">if (self.isLogin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">if (self.isLogin &#x3D;&#x3D; YES) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>如果返回值为BOOL值,必须确保返回值为YES或NO,最好不要存在多值的情况;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">- (BOOL)isLogin &#123;</span><br><span class="line">    return self.userToken.length !&#x3D; 0 ? YES : NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">- (BOOL)isLogin &#123;</span><br><span class="line">    return self.userToken.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####条件语句<br>######if else 条件语句</p><ul><li>条件语句的语句体，即便只有一行，也不能省略花括弧;</li><li>判断条件之后空1格,紧随左大括号{,无需换号;但是右大括号}必须另取一行;</li><li>else或 elseif应紧随在右大括号}之后,并且中间空1格;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">if (isLogin) &#123;</span><br><span class="line">    &#x2F;&#x2F; Do Something</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; DO Something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">if (isLogin) </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Do Something</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">    &#x2F;&#x2F; DO Something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">if (error &#x3D;&#x3D; nil) &#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">if (error &#x3D;&#x3D; nil)</span><br><span class="line">    return success;</span><br></pre></td></tr></table></figure><ul><li>多层嵌套的条件语句，优先考虑条件不成立可以立即跳出的情况;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 优先考虑可以跳出的流程</span><br><span class="line">if (!a) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!b) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!c) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不建议使用嵌套的方式</span><br><span class="line">if (a) &#123;</span><br><span class="line">    if (b) &#123;</span><br><span class="line">        if (c) &#123;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>三目运算只有在能增加代码清晰度和整洁度的时候才推荐使用;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">NSInteger value &#x3D; 5;</span><br><span class="line">result &#x3D; (value !&#x3D; 0) ? x : y;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">result &#x3D; a &gt; b ? x &#x3D; c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure><p>######switch case 语句</p><ul><li>switch case如果判断条件是枚举类型的值,则case也应该为枚举值,而不是 case 1;并且可以省略default处理;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType &#x3D; RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line">switch (menuType) &#123;</span><br><span class="line">  case RWTLeftMenuTopItemMain:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    break;</span><br><span class="line">  case RWTLeftMenuTopItemShows:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    break;</span><br><span class="line">  case RWTLeftMenuTopItemSchedule:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####其他规则</p><ul><li><p>初始化方法(构造方法)规则</p><ul><li>初始化方法的返回类型用instancetype,而不是用id;</li><li>如果重写init方法,必须调用[super init]方法;</li></ul></li><li><p>直接放回对应数据时,无需添加get, calc单词;</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)cellHeight;      &#x2F;&#x2F; 正确</span><br><span class="line"></span><br><span class="line">- (CGFloat)getCellHeight;   &#x2F;&#x2F; 错误</span><br><span class="line">- (CGFloat)calcCellHeight;  &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure><ul><li><p>单例的声明和使用规则</p><ul><li>获取单例的类方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static id sharedInstance &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UIApplication的使用规则<ul><li>获取单例的方法不使用点语法;</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure><ul><li>设置常用属性,直接使用点语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">self.view.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">[self.view setBackgroundColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure><ul><li>协议和代理方法命名规则<ul><li>协议方法名开头应与类名一样(不包含前缀);</li><li>必须将本身作为参数传递给外部,如(UITableView *)tableView;</li><li>传递所需参数给外部,如(NSIndexPath *)indexPath;</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure><ul><li>可以使用({})语法模块化设置控件属性(可选)<ul><li>要使用({})语法,前提: 该属性需由strong修饰;</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 前提: 该属性需由strong修饰</span><br><span class="line">&#x2F;** 名称Label *&#x2F;</span><br><span class="line">@property (nonatomic, strong) UILabel *nameLabel;</span><br><span class="line"></span><br><span class="line">self.nameLabel &#x3D; (&#123;</span><br><span class="line">        UILabel *label &#x3D; [[UILabel alloc] init];</span><br><span class="line">        label.textAlignment &#x3D; NSTextAlignmentCenter;</span><br><span class="line">        label.font &#x3D; [UIFont systemFontOfSize:12];</span><br><span class="line">        label.textColor &#x3D; [UIColor orangeColor];</span><br><span class="line">        label;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;说明：规范的目的是提高效率，所使用的规范应该是适应当前团队的。&lt;br&gt;####项目工程结构&lt;br&gt;#####代码结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现文件中的代码结构，提倡以下约定：&lt;ul&gt;
&lt;li&gt;用#pragma mark -将函数或方法按功能进行分组;&lt;/li&gt;
&lt;li&gt;分组之间空2行,方法之间空1行;&lt;/li&gt;
&lt;li&gt;delgate或协议相关方法放到一般内容之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="编码规范" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>iOS 数据解析之使用TFHpple解析html</title>
    <link href="http://example.com/2017/01/15/iOS%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8TFHpple%E8%A7%A3%E6%9E%90html/"/>
    <id>http://example.com/2017/01/15/iOS%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BD%BF%E7%94%A8TFHpple%E8%A7%A3%E6%9E%90html/</id>
    <published>2017-01-15T10:27:04.000Z</published>
    <updated>2020-09-26T14:05:21.922Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="https://github.com/topfunky/hpple">TFHpple</a>是一个XML/HTML解析框架，我们可以用来解析从后台发送过来的HTML数据。<br>　　如果要在项目中使用这个框架，首先需要将其导入，在这里使用CocoaPods将其导入。</p><p>　　下面是TFHpple的示例代码。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TFHpple.h&quot;</span><br><span class="line"></span><br><span class="line">NSData  * data      &#x3D; [NSData dataWithContentsOfFile:@&quot;index.html&quot;];</span><br><span class="line"></span><br><span class="line">TFHpple * doc       &#x3D; [[TFHpple alloc] initWithHTMLData:data];</span><br><span class="line">NSArray * elements  &#x3D; [doc search:@&quot;&#x2F;&#x2F;a[@class&#x3D;&#39;sponsor&#39;]&quot;];</span><br><span class="line"></span><br><span class="line">TFHppleElement * element &#x3D; [elements objectAtIndex:0];</span><br><span class="line">[e text];                       &#x2F;&#x2F; The text inside the HTML element (the content of the first text node)</span><br><span class="line">[e tagName];                    &#x2F;&#x2F; &quot;a&quot;</span><br><span class="line">[e attributes];                 &#x2F;&#x2F; NSDictionary of href, class, id, etc.</span><br><span class="line">[e objectForKey:@&quot;href&quot;];       &#x2F;&#x2F; Easy access to single attribute</span><br><span class="line">[e firstChildWithTagName:@&quot;b&quot;]; &#x2F;&#x2F; The first &quot;b&quot; child node</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从中可以看出要解析HTML中的内容分四步：</p><ul><li>将HTML数据转换为NSData类型；</li><li>根据data创建TFHpple实例；</li><li>查找节点存入数组；</li><li>从数组中取出节点。</li></ul><p>　　接下来使用TFHpple解析<code>http://www.jianshu.com/u/b05772019513</code>中的数据，获取到每篇文章的标题。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-c2c0ec1517b3b5e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标题"></p><p>　　代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSString *url &#x3D; @&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;b05772019513&quot;;</span><br><span class="line"></span><br><span class="line">NSData *data &#x3D; [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]];</span><br><span class="line"></span><br><span class="line">TFHpple *xpathParser &#x3D; [[TFHpple alloc] initWithHTMLData:data];</span><br><span class="line"></span><br><span class="line">NSArray *dataArr &#x3D; [xpathParser searchWithXPathQuery:@&quot;&#x2F;&#x2F;a&quot;];</span><br><span class="line"></span><br><span class="line">for (TFHppleElement *element in dataArr) &#123;</span><br><span class="line">    </span><br><span class="line">    if ([[element objectForKey:@&quot;class&quot;] isEqualToString:@&quot;title&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,element.text);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-22d92424069fd1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析结果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　&lt;a href=&quot;https://github.com/topfunky/hpple&quot;&gt;TFHpple&lt;/a&gt;是一个XML/HTML解析框架，我们可以用来解析从后台发送过来的HTML数据。&lt;br&gt;　　如果要在项目中使用这个框架，首先需要将其导入，在这里使用CocoaPods将其导入。&lt;/p&gt;
&lt;p&gt;　　下面是TFHpple的示例代码。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="数据解析" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="http://example.com/2017/01/08/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2017/01/08/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2017-01-08T15:42:42.000Z</published>
    <updated>2020-09-26T14:03:20.873Z</updated>
    
    <content type="html"><![CDATA[<p>######创建版本库<br>初始化一个Git仓库，使用git init命令。<br>添加文件到Git仓库，分两步：第一步，使用命令git add <file>，可反复多次使用，添加多个文件；第二步，使用命令git commit，完成。git add把把文件修改添加到暂存区；git commit提交更改，就是把暂存区的所有内容提交到当前分支。每次修改，如果不add到暂存区，那就不会加入到commit中。</p><p>######查看状态<br>查看工作区的状态，使用git status命令。<br>如果git status告诉有文件被修改过，用git diff可以查看修改内容。<br>使用git log查看版本库现在的状态。</p><a id="more"></a><p>######版本回退<br>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。<br>用git log可以查看提交历史，以便确定要回退到哪个版本。<br>用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><p>######撤销修改<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。git checkout其实是用版本库里的版本替换工作区的版本<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><p>######删除文件<br>命令git rm file用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><p>######创建与合并分支相关<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name>，合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。git merge –no-ff -m “merge with no-ff” dev 将dev分支以普通模式合并到当前分支<br>删除分支：git branch -d <name><br>查看分支合并图：git log –graph</p><p>######Bug分支<br>git stash 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br>git checkout master<br>git checkout -b issue-101<br>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：<br>git checkout master<br>git merge –no-ff -m “merged bug fix 101” issue-101<br>git branch -d issue-101<br>回到dev分支干活<br>git checkout dev<br>git stash list // git stash list命令看看储藏了那些stash<br>需要恢复到储藏前，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；<br>另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{x}  // x为stash list 号</p><p>######Feature分支<br>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</p><p>######添加远程库<br>本地git仓库要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>#####从远程库克隆<br>要克隆一个仓库，首先必须知道远程仓库的地址，然后使用git clone命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p><p>######分支策略<br>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-b9433e012590a25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="团队合作分支示意图(图片来自廖雪峰的官方网站)"></p><p>######多人协作<br>远程仓库默认名称origin<br>查看远程库的信息：git remote<br>显示更详细的信息：git remote -v<br>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：git push origin master 将master分支推送至远程库的master，git push origin dev 将dev分支推送至远程库的dev</p><p>多人协作的工作模式通常为：<br>　　首先，可以试图用git push origin branch-name推送自己的修改；<br>　　如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>　　如果合并有冲突，则解决冲突，并在本地提交；<br>　　没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>　　如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看远程库信息，使用git remote -v；</span><br><span class="line">本地新建的分支如果不推送到远程，对其他人就是不可见的；</span><br><span class="line">从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</span><br><span class="line">在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</span><br><span class="line">建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin&#x2F;branch-name；</span><br><span class="line">从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</span><br></pre></td></tr></table></figure><p>######标签管理<br>首先，切换到需要打标签的分支上。<br>打标签：git tag v1.0 默认标签是打在最新提交的commit上。<br>查看所有标签：git tag<br>找到历史提交的commit id：git log –pretty=oneline –abbrev-commit<br>为commit id为6224937的commit打标签：git tag v0.9 6224937<br>查看标签信息：git show <tagname><br>删除标签：git tag -d v0.1<br>推送标签：git push origin v1.0<br>一次性推送全部尚未推送到远程的本地标签：git push origin –tags<br>删除远程标签：先从本地删除：git tag -d v0.9 再从远程删除：git push origin :refs/tags/v0.9</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;######创建版本库&lt;br&gt;初始化一个Git仓库，使用git init命令。&lt;br&gt;添加文件到Git仓库，分两步：第一步，使用命令git add &lt;file&gt;，可反复多次使用，添加多个文件；第二步，使用命令git commit，完成。git add把把文件修改添加到暂存区；git commit提交更改，就是把暂存区的所有内容提交到当前分支。每次修改，如果不add到暂存区，那就不会加入到commit中。&lt;/p&gt;
&lt;p&gt;######查看状态&lt;br&gt;查看工作区的状态，使用git status命令。&lt;br&gt;如果git status告诉有文件被修改过，用git diff可以查看修改内容。&lt;br&gt;使用git log查看版本库现在的状态。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
    <category term="常用命令" scheme="http://example.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码关闭App、配置后台运行模式</title>
    <link href="http://example.com/2016/12/22/iOS%20%E4%BB%A3%E7%A0%81%E5%85%B3%E9%97%ADApp%E3%80%81%E9%85%8D%E7%BD%AE%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2016/12/22/iOS%20%E4%BB%A3%E7%A0%81%E5%85%B3%E9%97%ADApp%E3%80%81%E9%85%8D%E7%BD%AE%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-12-22T12:09:30.000Z</published>
    <updated>2020-09-26T14:01:21.123Z</updated>
    
    <content type="html"><![CDATA[<p>####代码关闭App<br>方法一：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)exitApplication&#123;</span><br><span class="line">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class="line">    UIWindow *window &#x3D; app.window;</span><br><span class="line">    </span><br><span class="line">    [UIView animateWithDuration:1.0f animations:^&#123;</span><br><span class="line">        window.alpha &#x3D; 0;</span><br><span class="line">        window.frame &#x3D; CGRectMake(0, window.bounds.size.width, 0, 0);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)exitApplication &#123;</span><br><span class="line">    </span><br><span class="line">    [UIView beginAnimations:@&quot;exitApplication&quot; context:nil];</span><br><span class="line">    </span><br><span class="line">    [UIView setAnimationDuration:0.5];</span><br><span class="line">    </span><br><span class="line">    [UIView setAnimationDelegate:self];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; [UIView setAnimationTransition:UIViewAnimationCurveEaseOut forView:self.view.window cache:NO];</span><br><span class="line">    </span><br><span class="line">    AppDelegate *delegate &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class="line">    </span><br><span class="line">    [UIView setAnimationTransition:UIViewAnimationCurveEaseOut forView:delegate.window cache:NO];</span><br><span class="line">    </span><br><span class="line">    [UIView setAnimationDidStopSelector:@selector(animationFinished:finished:context:)];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;self.view.window.bounds &#x3D; CGRectMake(0, 0, 0, 0);</span><br><span class="line">    </span><br><span class="line">    delegate.window.bounds &#x3D; CGRectMake(0, 0, 0, 0);</span><br><span class="line">    </span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animationFinished:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context &#123;</span><br><span class="line"></span><br><span class="line">    if ([animationID compare:@&quot;exitApplication&quot;] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####配置后台运行模式<br>　　在工程的info.plist 文件中，可以通过添加Required background modes (后台工作模式)属性，来实现后台运行一些操作，比如蓝牙、音频、视频、网络处理等。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-3edecb5db8d26326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS App 在后台运行支持的一些操作"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;####代码关闭App&lt;br&gt;方法一：&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="后台运行" scheme="http://example.com/tags/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    
    <category term="关闭App" scheme="http://example.com/tags/%E5%85%B3%E9%97%ADApp/"/>
    
  </entry>
  
  <entry>
    <title>项目托管到GitHub及简单使用</title>
    <link href="http://example.com/2016/12/13/%E9%A1%B9%E7%9B%AE%E6%89%98%E7%AE%A1%E5%88%B0GitHub%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2016/12/13/%E9%A1%B9%E7%9B%AE%E6%89%98%E7%AE%A1%E5%88%B0GitHub%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2016-12-13T14:00:13.000Z</published>
    <updated>2020-09-26T14:04:03.265Z</updated>
    
    <content type="html"><![CDATA[<p>####GitHub<br>　　GitHub是一个面向开源及私有软件项目的托管平台，也是基于Ｇit的开源分布式版本控制系统。在GitHub出现之前，开发者想要将自己的项目开源很容易实现，但是如果想让其他开发者一起参与到开源项目提交代码，就需要想提交代码的开发者把diff文件发给官方仓库开发者才能实现提交，也即只有创立那个开源项目的开发者才拥有仓库的写权限。GitHub出现后，利用其强大的克隆及分支功能，广大的开发者便可以自由的参与到各种开源项目。那么问题来了，我们该如何参与开源项目呢？比如非常讨人喜欢的<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>网络库。</p><p>####参与到开源项目<br>　　首先，我们可以访问项目主页<a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a>点击Fork，这样就在自己的账户下克隆了一个AFNetwroking仓库，然后从自己的账户下clone:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:DH-Fantasy&#x2F;AFNetworking.git</span><br></pre></td></tr></table></figure><p>　　这样就可以将修改的代码往自己的仓库进行推送。如果你希望AFNetworking的官方库接受你修改的代码，你可以在GitHub上发起一个Pull Request。当然，接不接受那就不一定了，即便如此，还是加油吧！<br>　　需要注意的是一定要在自己的账户下clone仓库，如果从AFNetworking作者的仓库<code>git@github.com:AFNetworking/AFNetworking.git</code>进行clone，由于没有写的权限，修改的代码将不能推送。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-0a178969d2e43527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>　　通过上述内容，你应该已经对如何参与到一个开源项目的流程有了大概的认识。如果想要加深这方面的知识，请点击：<a href="https://guides.github.com/activities/contributing-to-open-source/"> Contributing to Open Source on GitHub</a>或译文<a href="http://blog.csdn.net/lanxuezaipiao/article/details/23546349">如何参与一个GitHub开源项目？</a>那么接下来我们思考下如何将自己的项目进行开源？以供别的开发者参与进来。</p><p>####开源自己的项目<br>　　那么我们该怎么将本地的代码上传至GitHub，以供别的开发者参与进来进行修改？我们需要完成以下几步。<br>　　Step1：安装Git并配置Git账户信息<br>　　安装Git有两种方法：<br>　　1.首先安装homebrew，然后通过homebrew安装Git，具体的安装方法可以参考<a href="http://brew.sh/index_zh-cn.html">homebrew的文档</a>。<br>　　2.直接从AppStore安装Xcode，Xcode集成了Git，最新版的Xcode已经默认安装好了Git。完成安装之后，就可以使用 Git 的命令行工具。<br>　　配置Git账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>　　邮箱为注册GitHub的邮箱<br>　　Step2：创建本地SSH keys<br>　　生成密钥文件和私钥文件。使用该命令之后, 会出现提示选择SSH keys<br>生成路径, 直接点回车默认即可, 生成的SSH keys在默认路径中；如果不需要使用密码进行登入，就一路回车下去即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C&quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-39a3bffe521f6a8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ssh-keygen -t rsa -C&quot;邮箱&quot;"></p><p>　　检查SSH keys是否存在以验证本地SSH keys是否创建成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~&#x2F;.ssh</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-960a63a7e869b8eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检查SSH keys是否存在"></p><p>　　使用ssh-add将生成的private key加入到ssh agent中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure><p>　　将SSH key从文件拷贝到粘贴板中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>　　打开GitHub -&gt; SSH and GPG keys -&gt; New SSH key<br>　　Title 随便填，command + Ｖ 将SSH key填入key，点击Add SSH key<br>　　回到终端执行<code>ssh git@github.com</code>测试下是否成功</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-44881f764fe4b9ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置 SSH key 成功"></p><p>　　Step3：创建本地库及远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd 到当前工程路径</span><br><span class="line">echo &quot;# DHAudioDemo&quot; &gt;&gt; README.md</span><br><span class="line">git init                           &#x2F;&#x2F;初始化本地库</span><br><span class="line">git add .                          &#x2F;&#x2F;将工程添加到索引库</span><br><span class="line">git commit -m &quot;first commit&quot;       &#x2F;&#x2F;将工程添加到本地缓存区</span><br><span class="line">在远程创建一个库（也可以为已拥有的远程库）</span><br><span class="line">git remote add origin git@github.com:path&#x2F;projectName.git &#x2F;&#x2F; 如果第一次则需要将远程库和本地库进行连接，之后不需要</span><br><span class="line">git push                    &#x2F;&#x2F; 如果第一次push到远程库则使用git push -u origin master推送master分支的所有内容</span><br></pre></td></tr></table></figure><p>　　如果当前分支只有一个追踪分支，那么主机名可以省略，直接使用<code>git push</code>；如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，如：<code>git push -u origin master</code>命令将本地的master分支的内容推送到origin主机，同时指定origin为默认主机，这样后面就可以不加任何参数使用<code>git push</code>。<br>　　如果输入<code>git remote add origin git@github.com:(GitHub账户名)/(项目名).git</code><br>　　出现错误：fatal: remote origin already exists.<br>　　解决办法如下：<br>　　1.先输入<code>git remote rm origin</code>；<br>　　2.再输入<code>git remote add origin git@github.com:DH-Fantasy/DHAudioDemo.git</code>就不会报错。</p><p>####Git远程库相关操作<br>修改远程库地址命令<br><code>git remote set-url origin Newurl</code><br>删除当前远程库关联<br><code>git remote rm origin</code><br>添加新的远程库关联<br><code>git remote add origin git@github.com:GitHub用户名/项目名.git</code></p><p>####参考链接<br><a href="http://blog.igevin.info/posts/generate-ssh-key-for-git/">1.如何生成SSH key</a><br><a href="https://segmentfault.com/a/1190000002533334">2.如何在本地环境配置GitHub</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000">3.使用GitHub</a><br><a href="http://blog.csdn.net/dengjianqiang2011/article/details/9260435">4.GitHub常见操作和常见错误！错误提示：fatal: remote origin already exists. </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;####GitHub&lt;br&gt;　　GitHub是一个面向开源及私有软件项目的托管平台，也是基于Ｇit的开源分布式版本控制系统。在GitHub出现之前，开发者想要将自己的项目开源很容易实现，但是如果想让其他开发者一起参与到开源项目提交代码，就需要想提交代码的开发者把diff文件发给官方仓库开发者才能实现提交，也即只有创立那个开源项目的开发者才拥有仓库的写权限。GitHub出现后，利用其强大的克隆及分支功能，广大的开发者便可以自由的参与到各种开源项目。那么问题来了，我们该如何参与开源项目呢？比如非常讨人喜欢的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;网络库。&lt;/p&gt;
&lt;p&gt;####参与到开源项目&lt;br&gt;　　首先，我们可以访问项目主页&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;https://github.com/AFNetworking/AFNetworking&lt;/a&gt;点击Fork，这样就在自己的账户下克隆了一个AFNetwroking仓库，然后从自己的账户下clone:&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
    <category term="项目托管" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E6%89%98%E7%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS CocoaPods安装及使用教程</title>
    <link href="http://example.com/2016/08/12/iOS%20CocoaPods%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2016/08/12/iOS%20CocoaPods%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2016-08-12T14:45:56.000Z</published>
    <updated>2020-09-26T14:05:01.036Z</updated>
    
    <content type="html"><![CDATA[<p>   Xcode-&gt;Homebrew-&gt;RVM-&gt;Ruby-&gt;CocoaPods<br>  上面是安装顺序，所以要想安装CocoaPods，必须先确认你的电脑是否安装了Ruby环境。打开终端输入<code>ruby -v</code>即可查看是否安装Ruby环境。</p><pre><code>ruby -vruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15]</code></pre><p>  如果安装了Ruby环境请直接移步后面CocoaPods安装，没有的话我们继续。</p><p>####Xcode<br>  Xcode就不说了。</p><a id="more"></a><p>####Homebrew<br>  linux系统有软件包依赖问题，好在Red hat有yum、Ubuntu有apt-get。而Mac OS却没有类似的，所以就有了第三方支持：Homebrew，简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件。<br>  Homebrew的安装很简单，只需要去<a href="http://brew.sh/index_zh-cn.html">官网</a>将下图中用红色圈住的脚本复制到终端回车就行，当然也可以复制下面的脚本使用，你开心就好。</p><pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1690826-47b2518877a5703d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Homebrew"></p><p>######Homebrew使用<br>  就举例常用的吧(从hen没hao用yong过)，更多使用方法自己去<a href="http://brew.sh/index_zh-cn.html">官网</a>挖掘吧！<br>搜索软件：<code>brew search 软件名，如brew search wget</code><br>安装软件：<code>brew install 软件名，如brew install wget</code><br>卸载软件：<code>brew remove 软件名，如brew remove wget</code></p><p>####RVM<br>  <a href="https://rvm.io/">RVM</a>(Ruby Version Manager)是一个命令行工具，可以提供一个便捷的多版本Ruby环境的管理和切换。安装命令”curl -L get.rvm.io | bash -s stable”。RVM使用过程中所有命令都是在用户权限下操作，所以任何命令最好都不要用sudo、gem。<br>######RVM安装</p><pre><code>curl -L get.rvm.io | bash -s stable% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current Dload  Upload   Total   Spent    Left  Speed100   184  100   184    0     0    218      0 --:--:-- --:--:-- --:--:--   218100 22865  100 22865    0     0   8327      0  0:00:02  0:00:02 --:--:-- 20004Downloading https://github.com/rvm/rvm/archive/1.27.0.tar.gzDownloading https://github.com/rvm/rvm/releases/download/1.27.0/1.27.0.tar.gz.ascFound PGP signature at: &#39;https://github.com/rvm/rvm/releases/download/1.27.0/1.27.0.tar.gz.asc&#39;,but no GPG software exists to validate it, skipping.Installing RVM to /Users/Fantasy/.rvm/Adding rvm PATH line to /Users/Fantasy/.profile /Users/Fantasy/.mkshrc /Users/Fantasy/.bashrc /Users/Fantasy/.zshrc.Adding rvm loading line to /Users/Fantasy/.profile /Users/Fantasy/.bash_profile /Users/Fantasy/.zlogin.Installation of RVM in /Users/Fantasy/.rvm/ is almost complete:* To start using RVM you need to run `source /Users/Fantasy/.rvm/scripts/rvm`in all your open shell windows, in rare cases you need to reopen all shell windows.# Fantasy,##   Thank you for using RVM!#   We sincerely hope that RVM helps to make your life easier and more enjoyable!!!## ~Wayne, Michal &amp; team.In case of problems: https://rvm.io/help and https://twitter.com/rvm_io</code></pre><p>  载入RVM</p><pre><code>source ~/.rvm/scripts/rvm</code></pre><p>  检查安装是否正确</p><pre><code>rvm -vrvm 1.27.0 (latest) by Wayne E. Seguin &lt;wayneeseguin@gmail.com&gt;, Michal Papis &lt;mpapis@gmail.com&gt; [https://rvm.io/]</code></pre><p>  列出已知的Ruby版本</p><pre><code>rvm list known</code></pre><p>　　获取更多的RVM知识请点击<a href="http://ruby-china.org/wiki/rvm-guide">RVM实用指南</a></p><p>####Ruby<br>  <a href="https://www.ruby-lang.org/zh_cn/">Ruby</a>是开源的面向对象程序设计的服务器端脚本语言。想挖掘更多关于Ruby信息请移步<a href="https://ruby-china.org/">Ruby China</a>、<a href="https://www.ruby-lang.org/zh_cn/">Ruby</a>。<br>######Ruby安装<br>  如果使用RVM的Ruby安装源的话会比较慢，可以修改到Ruby China的Ruby镜像服务器提高安装速度。</p><pre><code>echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db</code></pre><p>  <code>rvm list known</code>列表里面的都可以用来安装，这里安装最新的稳定版本2.3.1。</p><pre><code>rvm install 2.3.1</code></pre><p>  切换到Ruby版本。</p><pre><code>rvm use 2.3.1</code></pre><p>  设置默认版本，这样以后新打开的终端默认的Ruby就是这个版本。</p><pre><code>rvm use 2.3.1 --default </code></pre><p>  检查当前使用的Ruby版本</p><pre><code>ruby -vruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15]</code></pre><p>  查询已安装的Ruby</p><pre><code>rvm list</code></pre><p>  卸载一个已安装版本</p><pre><code>rvm remove 2.2.0</code></pre><p>  获取管理员权限更新系统的Ruby</p><pre><code>sudo gem update --system</code></pre><p>####CocpaPods<br>  <a href="https://cocoapods.org/">CocoaPods</a>是一个负责管理iOS项目中第三方开源库的工具。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得开发人员节省了设置和更新第三方开源库的时间。<br>######CocoaPods安装<br>  Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问(bei)题(qiang)，解决方案是将其替换成Ruby China镜像。<br>查看Ruby的默认源。</p><pre><code>gem sources -l</code></pre><p>  移除Ruby默认源并使用Ruby China镜像</p><pre><code>gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code></pre><p>  使用<code>gem sources -l</code>查看是否替换成功</p><pre><code>*** CURRENT SOURCES ***https://gems.ruby-china.org/</code></pre><p>  安装CocoaPods</p><pre><code>sudo gem install cocoapods</code></pre><p>  <strong><strong>备注</strong></strong>：OS X EL Capitan 后安装改为</p><pre><code>sudo gem install -n /usr/local/bin cocoapods</code></pre><p>  在安装进程结束的时候，执行命令：</p><pre><code>pod setup</code></pre><p>######CocoaPods升级<br>  升级很简单，再次执行安装命令即可。</p><pre><code>sudo gem install cocoapods</code></pre><p>  <strong><strong>注意：</strong></strong>如果安装的时候使用了sudo，升级的时候一样需要使用该关键字，不然升级完了以后会出现路径不匹配问题。</p><p>####CocoaPods使用<br>1.新建一个项目，名字Test_CocoaPods<br><img src="http://upload-images.jianshu.io/upload_images/1690826-c84a153ad59f7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Test_CocoaPods.png"></p><p>2.终端​cd到项目总目录</p><pre><code>cd /Users/Fantasy/Desktop/Test_CocoaPods</code></pre><p>3.建立Podfile(配置文件)</p><pre><code>vim Podfile</code></pre><p>4.键盘输入 <strong><strong>i</strong></strong> 进入编辑模式，输入：</p><pre><code>platform :ios, &#39;7.0&#39;pod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;</code></pre><p>  然后按<code>Esc</code>，并且输入<code> ：</code>号进入vim命令模式，然后在<code> ：</code>后边输入<code>wq</code>进行保存并退出，执行<code>pod install</code><br>  如果报错<code>[!] The dependency `SDWebImage (~&gt; 3.8)` is not used in any concrete target.</code>则输入：</p><pre><code>platform :ios, &#39;7.0&#39;target &#39;Test_CocoaPods&#39; dopod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;end</code></pre><p><strong><strong>注意：</strong></strong>target 后面的Test_CocoaPods为工程名。<br>5.打开项目<br>  点击Test_CocoaPods.xcworkspace，而不是点击Test_CocoaPods.xodeproj</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-24c73b511a64e4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Test_CocoaPods.xcworkspace"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-3352b9ab8ca70a95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage .png"><br>6.接下来测试一下<br>  6.1在<code>ViewController</code>中导入<code>#import &quot;UIImageView+WebCache.h&quot;</code><br>  6.2创建一个<code>UIImageView</code>的对象并调用<code>sd_setImageWithURL:(NSURL *)url</code><br>    <code>[test_ImageView sd_setImageWithURL:url];</code><br>  6.3运行结果</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-653ad90cdd9b15ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="run results.png"></p><p>####总结</p><ol><li>用 CocoaPods进行管理，修改第三方源码极不方便；</li><li>CocoaPods可以节省设置和更新第三方开源库的时间；</li><li>理解安装顺序(Xcode-&gt;Homebrew-&gt;RVM-&gt;Ruby-&gt;CocoaPods)对于安装CocoaPods有帮助。</li></ol><p>想挖掘更多关于CocoaPods的信息请移步<a href="https://github.com/CocoaPods/CocoaPods/wiki">CocoaPods wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;   Xcode-&amp;gt;Homebrew-&amp;gt;RVM-&amp;gt;Ruby-&amp;gt;CocoaPods&lt;br&gt;  上面是安装顺序，所以要想安装CocoaPods，必须先确认你的电脑是否安装了Ruby环境。打开终端输入&lt;code&gt;ruby -v&lt;/code&gt;即可查看是否安装Ruby环境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ruby -v
ruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-darwin15]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  如果安装了Ruby环境请直接移步后面CocoaPods安装，没有的话我们继续。&lt;/p&gt;
&lt;p&gt;####Xcode&lt;br&gt;  Xcode就不说了。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="CocoaPods" scheme="http://example.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS 即时通信系列之XMPP登入、注册、聊天</title>
    <link href="http://example.com/2016/08/01/iOS%20%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E5%88%97%E4%B9%8BXMPP%E7%99%BB%E5%85%A5%E3%80%81%E6%B3%A8%E5%86%8C%E3%80%81%E8%81%8A%E5%A4%A9/"/>
    <id>http://example.com/2016/08/01/iOS%20%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E5%88%97%E4%B9%8BXMPP%E7%99%BB%E5%85%A5%E3%80%81%E6%B3%A8%E5%86%8C%E3%80%81%E8%81%8A%E5%A4%A9/</id>
    <published>2016-08-01T08:32:09.000Z</published>
    <updated>2020-09-26T14:00:14.239Z</updated>
    
    <content type="html"><![CDATA[<p>说明：在<a href="http://www.jianshu.com/p/7c80a61c8de6">即时通信系列XMPP之搭建本地服务器</a>中阐述了通过XAMPP、Openfire工具搭建基于XMPP的服务器端，并使用spark软件进行XMPP客户端的调试。在本文中主要阐述将XMPP添加到工程中，实现iOS中基于XMPP的即时通信。<br>####项目环境配置<br>　　使用CocoaPods导入XMPP框架，如果不会CocoaPods，点击<a href="http://www.jianshu.com/p/5c66c0c1ee87">CocoaPods安装及使用教程</a>，或者<a href="http://www.jianshu.com/p/e2d018758842">手动导入XMPP框架</a>。</p><p>####创建XMPP管理类<br>　　为了让XMPP不会对工程中其它业务代码具有侵入性，方便我们管理整个关于XMPP的逻辑处理，通常会采用单例模式新建一个专门的管理类，为此，在工程中创建一个继承自NSObject的XMPPManger，为了能够在代码中方便调用XMPPStreamDelegate的方法，让其遵守XMPPStreamDelegate协议。<br>　　XMPP框架中所有的连接、登入、注册、授权、失去连接等操作的回调都是通过XMPPStream来管理，所以XMPPManger必须有一个XMPPStream实例。其它的还包括进行添加好友、删除好友、获取好友列表等功能的XMPPRoster；消息保存组件XMPPMessageArchiving等。</p><p>######XMPPManager.h</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface XMPPManager : NSObject&lt;XMPPStreamDelegate&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  创建全局唯一的管理者对象</span><br><span class="line"> *  @return 返回一个单例对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (XMPPManager *)sharedXMPPManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  信息管道</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic,strong)XMPPStream *stream;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  进行添加好友 删除好友 获取好友列表等功能</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic,strong)XMPPRoster *roster;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  消息保存组件</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic,strong)XMPPMessageArchiving *messageArchiving;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  消息保存组件的CoreData上下文</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic,strong)NSManagedObjectContext *managerObjectContext;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  登入</span><br><span class="line"> *</span><br><span class="line"> *  @param userName 账户</span><br><span class="line"> *  @param password 密码</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)loginWithUserName:(NSString *)userName password:(NSString *)password;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *  注册</span><br><span class="line"> *</span><br><span class="line"> *  @param userName 账户</span><br><span class="line"> *  @param password 密码</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)registWithUserName:(NSString *)userName password:(NSString *)password;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>######XMPPManager.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;服务器的地址</span><br><span class="line">static NSString *const kHostName &#x3D; @&quot;127.0.0.1&quot;;</span><br><span class="line">&#x2F;&#x2F;端口号</span><br><span class="line">static UInt16 const kHostPort &#x3D; 5222;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;连接服务器类型</span><br><span class="line">typedef NS_ENUM(NSUInteger,ConnectToServerStatus) &#123;</span><br><span class="line">    ConnectToServerStatusLogin,</span><br><span class="line">    ConnectToServerStatusRegist,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface XMPPManager ()</span><br><span class="line">&#x2F;&#x2F;登入密码</span><br><span class="line">@property (nonatomic,strong)NSString *loginpassword;</span><br><span class="line">&#x2F;&#x2F;注册密码</span><br><span class="line">@property (nonatomic,strong)NSString *registpassword;</span><br><span class="line">&#x2F;&#x2F;是登入还是注册</span><br><span class="line">@property (nonatomic,assign)ConnectToServerStatus connectToSercerStatus;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XMPPManager</span><br><span class="line"></span><br><span class="line">+ (XMPPManager *)sharedXMPPManager&#123;</span><br><span class="line">    static XMPPManager *xmppManager &#x3D; nil;</span><br><span class="line">    static dispatch_once_t token;</span><br><span class="line">    dispatch_once(&amp;token, ^&#123;</span><br><span class="line">        xmppManager &#x3D; [[XMPPManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return xmppManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if ([super init]) &#123;</span><br><span class="line">        &#x2F;&#x2F;设置通信管道属性</span><br><span class="line">        self.stream &#x3D; [[XMPPStream alloc] init];</span><br><span class="line">        self.stream.hostName &#x3D; kHostName;</span><br><span class="line">        self.stream.hostPort &#x3D; kHostPort;</span><br><span class="line">        &#x2F;&#x2F;设置当前对象为stream的代理</span><br><span class="line">        [self.stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;进行好友存储</span><br><span class="line">        XMPPRosterCoreDataStorage *rosterStorage &#x3D; [XMPPRosterCoreDataStorage sharedInstance];</span><br><span class="line">        self.roster &#x3D; [[XMPPRoster alloc] initWithRosterStorage:rosterStorage dispatchQueue:dispatch_get_main_queue()];</span><br><span class="line">        &#x2F;&#x2F;激活</span><br><span class="line">        [self.roster activate:self.stream];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;进行聊天信息存储</span><br><span class="line">        XMPPMessageArchivingCoreDataStorage *messageArchivingStorage &#x3D; [XMPPMessageArchivingCoreDataStorage sharedInstance];</span><br><span class="line">        self.messageArchiving &#x3D; [[XMPPMessageArchiving alloc] initWithMessageArchivingStorage:messageArchivingStorage dispatchQueue:dispatch_get_main_queue()];</span><br><span class="line">        [self.messageArchiving activate:self.stream];</span><br><span class="line">        </span><br><span class="line">        self.managerObjectContext &#x3D; messageArchivingStorage.mainThreadManagedObjectContext;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与服务器建立链接</span><br><span class="line">-(void)connectToServerWithUser:(NSString *)user&#123;</span><br><span class="line">    &#x2F;&#x2F;要是正在链接的话那么就先断开连接</span><br><span class="line">    if ([self.stream isConnected]) &#123;</span><br><span class="line">        [self disconnectServer];</span><br><span class="line">    &#125;</span><br><span class="line">    XMPPJID *jid &#x3D; [XMPPJID jidWithUser:user domain:@&quot;DH_Fantasy&quot; resource:@&quot;iPhone&quot;];</span><br><span class="line">    self.stream.myJID &#x3D; jid;</span><br><span class="line">    NSError *error &#x3D; nil;</span><br><span class="line">    [self.stream connectWithTimeout:30.0f error:&amp;error];</span><br><span class="line">    if (nil !&#x3D; error) &#123;</span><br><span class="line">        NSLog(@&quot;%s__%d__链接出错：%@&quot;,__FUNCTION__,__LINE__,error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;与服务器断开链接</span><br><span class="line">-(void)disconnectServer&#123;</span><br><span class="line">    [self.stream disconnect];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;登入</span><br><span class="line">- (void)loginWithUserName:(NSString *)userName password:(NSString *)password&#123;</span><br><span class="line">    self.connectToSercerStatus &#x3D; ConnectToServerStatusLogin;</span><br><span class="line">    self.loginpassword &#x3D; password;&#x2F;&#x2F;将传进来的password传给self.password</span><br><span class="line">    [self connectToServerWithUser:userName];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;注册</span><br><span class="line">- (void)registWithUserName:(NSString *)userName password:(NSString *)password&#123;</span><br><span class="line">    self.connectToSercerStatus &#x3D; ConnectToServerStatusRegist;</span><br><span class="line">    self.registpassword &#x3D; password;</span><br><span class="line">    [self connectToServerWithUser:userName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPStreamDelegate</span><br><span class="line">&#x2F;&#x2F;与服务器链接成功</span><br><span class="line">-(void)xmppStreamDidConnect:(XMPPStream *)sender&#123;</span><br><span class="line">#pragma mark 判断与服务器建立连接是登陆还是注册</span><br><span class="line">    switch (self.connectToSercerStatus) &#123;</span><br><span class="line">        case ConnectToServerStatusLogin:</span><br><span class="line">        &#123;</span><br><span class="line">            NSError *error &#x3D; nil;</span><br><span class="line">            [self.stream authenticateWithPassword:self.loginpassword error:&amp;error];</span><br><span class="line">            if (nil !&#x3D; error) &#123;</span><br><span class="line">                NSLog(@&quot;%s__%d__验证出错：%@&quot;,__FUNCTION__,__LINE__,error);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case ConnectToServerStatusRegist:</span><br><span class="line">        &#123;</span><br><span class="line">            NSError *err &#x3D; nil;</span><br><span class="line">            [self.stream registerWithPassword:self.registpassword error:&amp;err];</span><br><span class="line">            if (nil !&#x3D; err) &#123;</span><br><span class="line">                NSLog(@&quot;%s__%d__注册出错：%@&quot;,__FUNCTION__,__LINE__,err);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;与服务器链接失败</span><br><span class="line">-(void)xmppStreamConnectDidTimeout:(XMPPStream *)sender&#123;</span><br><span class="line">    NSLog(@&quot;😂与服务器链接失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xmppStreamWillConnect:(XMPPStream *)sender &#123;</span><br><span class="line">    NSLog(@&quot;🔌socket正在连接...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket &#123;</span><br><span class="line">    NSLog(@&quot;🍎socket连接成功&quot;);</span><br><span class="line">    &#x2F;&#x2F; 连接成功之后，由客户端xmpp发送一个stream包给服务器，服务器监听来自客户端的stream包，并返回stream feature包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error &#123;</span><br><span class="line">    NSLog(@&quot;😂xmpp授权失败:%@&quot;, error.description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender &#123;</span><br><span class="line">    NSLog(@&quot;🍎xmpp授权成功。&quot;);</span><br><span class="line">    &#x2F;&#x2F; 只有进入到这里，才算是真正的可以聊天了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error &#123;</span><br><span class="line">    NSLog(@&quot;😂xmpp失去连接。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>####AppDelegate<br>　　在AppDelegate中主要设置了下进入APP时的登入状态，在一些场景中，某些控制器必须为登入状态才能进入，用NSUserDefaults存储为Bool类型，这为判断是否登入提供了方便。</p><p>######AppDelegate.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置主窗口并显示</span><br><span class="line">    self.window &#x3D; [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    self.window.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置进入APP为没登入状态</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@&quot;isLoginStatus&quot;];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置好友列表控制器为根视图</span><br><span class="line">    RosterTableViewController *VC &#x3D; [[RosterTableViewController alloc] init];</span><br><span class="line">    UINavigationController *NC &#x3D; [[UINavigationController alloc] initWithRootViewController:VC];</span><br><span class="line">    self.window.rootViewController &#x3D; NC;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####RosterTableViewController<br>　　RosterTableViewController主要作用就是进行自动登入与显示获取到的好友。</p><p>######RosterTableViewController.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@interface RosterTableViewController ()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用于保存获取到的好友</span><br><span class="line">@property (nonatomic,strong)NSMutableArray *rosterArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RosterTableViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.title &#x3D; @&quot;好友列表&quot;;</span><br><span class="line">    </span><br><span class="line">    self.rosterArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断之前是否登入过</span><br><span class="line">    if (nil !&#x3D; [[NSUserDefaults standardUserDefaults]objectForKey:@&quot;userName&quot;]) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;之前登入过，直接读取用户名和密码进行连接</span><br><span class="line">        NSString *userName &#x3D; [[NSUserDefaults standardUserDefaults]objectForKey:@&quot;userName&quot;];</span><br><span class="line">        NSString *password &#x3D; [[NSUserDefaults standardUserDefaults]objectForKey:@&quot;password&quot;];</span><br><span class="line">        [[XMPPManager sharedXMPPManager]loginWithUserName:userName password:password];</span><br><span class="line">        [[XMPPManager sharedXMPPManager].stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">        </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;之前没登入过则进入到登入窗口</span><br><span class="line">        UIStoryboard *storyboard &#x3D; [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];</span><br><span class="line">        LoginViewController *loginVC &#x3D; [storyboard instantiateViewControllerWithIdentifier:@&quot;login&quot;];</span><br><span class="line">        </span><br><span class="line">        [self.navigationController pushViewController:loginVC animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[XMPPManager sharedXMPPManager].roster addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark UITableViewDataSource</span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">    return self.rosterArray.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    </span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</span><br><span class="line">    if (!cell) &#123;</span><br><span class="line">        cell &#x3D; [[UITableViewCell alloc] initWithStyle:(UITableViewCellStyleDefault) reuseIdentifier:@&quot;cell&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    XMPPJID *jid &#x3D; self.rosterArray[indexPath.row];</span><br><span class="line">    cell.textLabel.text &#x3D; jid.user;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 进入聊天界面</span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    XMPPJID *jid &#x3D; self.rosterArray[indexPath.row];</span><br><span class="line">    ChatViewController *chat &#x3D; [[ChatViewController alloc] init];</span><br><span class="line">    chat.chatToJid &#x3D; jid;</span><br><span class="line">    [self.navigationController pushViewController:chat animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPStreamDelegate</span><br><span class="line">&#x2F;&#x2F;授权成功</span><br><span class="line">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123;</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@&quot;isLoginStatus&quot;];</span><br><span class="line">    </span><br><span class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;我们验证之后默认的状态是离线的 于是我们想显示在线，需要告诉服务器自己的状态</span><br><span class="line">    XMPPPresence *presence &#x3D; [XMPPPresence presenceWithType:@&quot;available&quot;];</span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream sendElement:presence];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;验证失败</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error&#123;</span><br><span class="line">    NSLog(@&quot;登入验证失败😂&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPRosterDelegate</span><br><span class="line">&#x2F;&#x2F;刚开始获取好友列表</span><br><span class="line">-(void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender&#123;</span><br><span class="line">    NSLog(@&quot;开始获取好友列表&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正在获取好友列表</span><br><span class="line">-(void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(DDXMLElement *)item&#123;</span><br><span class="line">    NSLog(@&quot;正在获取好友列表...%@&quot;,item);</span><br><span class="line">    NSString *jidStr &#x3D; [[item attributeForName:@&quot;jid&quot;]stringValue];</span><br><span class="line">    XMPPJID *jid &#x3D;[XMPPJID jidWithString:jidStr];</span><br><span class="line">    [self.rosterArray addObject:jid];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将数据添加进数组</span><br><span class="line">    [self.tableView insertRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:self.rosterArray.count-1 inSection:0]] withRowAnimation:UITableViewRowAnimationLeft];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;已经完成好友列表获取</span><br><span class="line">-(void)xmppRosterDidEndPopulating:(XMPPRoster *)sender&#123;</span><br><span class="line">    NSLog(@&quot;已经完成好友列表获取🍅&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-41494ba1c8ffdb05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Friends List.png"></p><p>####LoginViewController<br>　　LoginViewController中使用XMPPManager单例在登入按钮的点击事件中调用<code>- (void)loginWithUserName:(NSString ***)userName password:(NSString *)password;</code>方法进行登入。</p><p>######LoginViewController.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface LoginViewController ()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;登入账户</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *userName;</span><br><span class="line">&#x2F;&#x2F;登入密码</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *password;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LoginViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;登入操作</span><br><span class="line">- (IBAction)loginAction:(id)sender &#123;</span><br><span class="line">    [[XMPPManager sharedXMPPManager] loginWithUserName:self.userName.text password:self.password.text];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPStreamDelegte</span><br><span class="line">&#x2F;&#x2F;验证成功</span><br><span class="line">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123;</span><br><span class="line">    &#x2F;&#x2F;存储账户密码用于下次自动登入</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:self.userName.text forKey:@&quot;userName&quot;];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:self.password.text forKey:@&quot;password&quot;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;改变APP的登入状态</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@&quot;isLoginStatus&quot;];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;验证之后默认的状态为离线，需要手动告诉服务器自己的状态</span><br><span class="line">    XMPPPresence *presence &#x3D; [XMPPPresence presenceWithType:@&quot;available&quot;];</span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream sendElement:presence];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;返回到根视图</span><br><span class="line">    [self.navigationController popToRootViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;验证失败</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error&#123;</span><br><span class="line">    NSLog(@&quot;登入验证失败😂&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-5c3c541d33fa98c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LoginViewController.png"></p><p>####RegisterViewController<br>　　注册和登入比较相似，只需在注册按钮的点击事件中使用XMPPManager单例调用<code>- (void)registWithUserName:(NSString *)userName password:(NSString *)password;</code>方法进行注册。</p><p>######RegisterViewController.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@interface RegisterViewController ()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册账户</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *userName;</span><br><span class="line">&#x2F;&#x2F;注册密码</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *password;</span><br><span class="line">&#x2F;&#x2F;密码验证</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *rePassword;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RegisterViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)registerAction:(id)sender &#123;</span><br><span class="line">    &#x2F;&#x2F;简单验证：用户名不为空且密码和密码验证输入一致</span><br><span class="line">    if (![self.userName.text isEqualToString:@&quot;&quot;] &amp;&amp; [self.rePassword.text isEqualToString:self.password.text]) &#123;</span><br><span class="line">        [[XMPPManager sharedXMPPManager] registWithUserName:self.userName.text password:self.password.text];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        UIAlertController *alertController &#x3D; [UIAlertController alertControllerWithTitle:@&quot;注册失败&quot; message:@&quot;&quot; preferredStyle:(UIAlertControllerStyleAlert)];</span><br><span class="line">        </span><br><span class="line">        if ([self.userName.text isEqualToString:@&quot;&quot;]) &#123;</span><br><span class="line">            alertController.title &#x3D; @&quot;账户为空&quot;;</span><br><span class="line">            alertController.message &#x3D; @&quot;请输入账户&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (![self.rePassword.text isEqualToString:self.password.text]) &#123;</span><br><span class="line">            alertController.title &#x3D; @&quot;密码验证错误&quot;;</span><br><span class="line">            alertController.message &#x3D; @&quot;请重新输入密码验证&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        UIAlertAction *okAction &#x3D; [UIAlertAction actionWithTitle:@&quot;OK&quot; style:(UIAlertActionStyleCancel) handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">            [alertController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [alertController addAction:okAction];</span><br><span class="line">        [self presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark--XMPPStreamDelegate</span><br><span class="line">&#x2F;&#x2F;注册成功</span><br><span class="line">-(void)xmppStreamDidRegister:(XMPPStream *)sender&#123;</span><br><span class="line">    NSLog(@&quot;%s__%d__注册成功&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;存储账户密码用于下次自动登入</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:self.userName.text forKey:@&quot;userName&quot;];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:self.password.text forKey:@&quot;password&quot;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;改变APP的登入状态</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@&quot;isLoginStatus&quot;];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;验证之后默认的状态为离线，需要手动告诉服务器自己的状态</span><br><span class="line">    XMPPPresence *presence &#x3D; [XMPPPresence presenceWithType:@&quot;available&quot;];</span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream sendElement:presence];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;注册成功之后返回到登陆界面</span><br><span class="line">    [self.navigationController popToRootViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;注册失败</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didNotRegister:(DDXMLElement *)error&#123;</span><br><span class="line">    NSLog(@&quot;%s__%d__注册失败%@&quot;,__FUNCTION__,__LINE__,error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-cae7a70d1143df39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RegisterViewController.png"></p><p>####ChatViewController<br>　　在ChatViewController中需要公开一个属性，用来接收好友列表页面传来的XMPPJID。<br>######ChatViewController.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface ChatViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong)XMPPJID *chatToJid;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>######ChatViewController.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">@interface ChatViewController ()&lt;UITableViewDataSource,UITableViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示消息</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITableView *messageContent;</span><br><span class="line">&#x2F;&#x2F;消息输入框</span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextView *messageTextView;</span><br><span class="line">&#x2F;&#x2F;键盘底部约束</span><br><span class="line">@property (weak, nonatomic) IBOutlet NSLayoutConstraint *messageTextfieldConstraint;</span><br><span class="line">&#x2F;&#x2F;存储消息数据</span><br><span class="line">@property (nonatomic,strong) NSMutableArray *allMessageArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ChatViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.messageTextView.text &#x3D; @&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    self.messageContent.delegate &#x3D; self;</span><br><span class="line">    self.messageContent.dataSource &#x3D; self;</span><br><span class="line">    </span><br><span class="line">    self.allMessageArray &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    &#x2F;&#x2F;将历史消息加入到数组</span><br><span class="line">    [self.allMessageArray addObjectsFromArray:[self fromDataBaseFetchResult]];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;监听键盘frame的改变</span><br><span class="line">    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(kbFrameWillChange:) name:UIKeyboardWillChangeFrameNotification object:nil];</span><br><span class="line">    </span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream addDelegate:self delegateQueue:dispatch_get_main_queue()];</span><br><span class="line">    </span><br><span class="line">    [self reloadMessage];</span><br><span class="line">    </span><br><span class="line">    self.messageContent.separatorStyle &#x3D; UITableViewCellSeparatorStyleNone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消息发送按钮</span><br><span class="line">- (IBAction)sendMessageAction:(id)sender &#123;</span><br><span class="line">    XMPPMessage *message &#x3D; [XMPPMessage messageWithType:@&quot;chat&quot; to:self.chatToJid];</span><br><span class="line">    &#x2F;&#x2F;要发送的消息添加到Body</span><br><span class="line">    [message addBody:self.messageTextView.text];</span><br><span class="line">    &#x2F;&#x2F;发送消息</span><br><span class="line">    [[XMPPManager sharedXMPPManager].stream sendElement:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;键盘即将改变frame</span><br><span class="line">- (void)kbFrameWillChange:(NSNotification *)noti&#123;</span><br><span class="line">    &#x2F;&#x2F;获取窗口的高度</span><br><span class="line">    CGFloat windowH &#x3D; [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">    &#x2F;&#x2F;键盘结束的frm</span><br><span class="line">    CGRect kbEndFrm &#x3D; [noti.userInfo [UIKeyboardFrameEndUserInfoKey]CGRectValue];</span><br><span class="line">    &#x2F;&#x2F;键盘结束的y值</span><br><span class="line">    CGFloat kbEndY &#x3D; kbEndFrm.origin.y;</span><br><span class="line">    self.messageTextfieldConstraint.constant &#x3D; windowH - kbEndY;</span><br><span class="line">    </span><br><span class="line">    [self scrollsToBottomAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)scrollsToBottomAnimated:(BOOL)animated&#123;</span><br><span class="line">    CGFloat offset &#x3D; self.messageContent.contentSize.height - self.messageTextfieldConstraint.constant - 55;</span><br><span class="line">    if (offset &gt; 0)&#123;</span><br><span class="line">        [self.messageContent setContentOffset:CGPointMake(0, offset) animated:animated];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark XMPPStreamDelegate</span><br><span class="line">&#x2F;&#x2F;发送信息成功</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didSendMessage:(XMPPMessage *)message&#123;</span><br><span class="line">    NSLog(@&quot;发送成功🍅&quot;);</span><br><span class="line">    [self reloadMessage];&#x2F;&#x2F;发送信息时刷新一次页面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发送信息失败</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didFailToSendMessage:(XMPPMessage *)message error:(NSError *)error&#123;</span><br><span class="line">    NSLog(@&quot;发送失败⚠️&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;收到信息</span><br><span class="line">-(void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message&#123;</span><br><span class="line">    NSLog(@&quot;收到消息%@&quot;,message);</span><br><span class="line">    if ([message isChatMessageWithBody]) &#123;</span><br><span class="line">        [self reloadMessage];&#x2F;&#x2F;收到信息是刷新一次页面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载聊天信息</span><br><span class="line">-(void)reloadMessage&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从数据库读取数据</span><br><span class="line">    NSArray *fetchedObjects &#x3D; [self fromDataBaseFetchResult];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 清空消息数组里的所有数据</span><br><span class="line">    [self.allMessageArray removeAllObjects];</span><br><span class="line">    &#x2F;&#x2F; 将新的聊天记录添加到数组中</span><br><span class="line">    [self.allMessageArray addObjectsFromArray:fetchedObjects];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将信息加载到tableView上</span><br><span class="line">    [self.messageContent reloadData];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;加载时滚动到最底部</span><br><span class="line">    [self scrollToBottomWithAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从数据库读取数据</span><br><span class="line">- (NSArray *)fromDataBaseFetchResult&#123;</span><br><span class="line">    &#x2F;&#x2F;1.上下文</span><br><span class="line">    NSManagedObjectContext *managerObjectContext &#x3D;[XMPPManager sharedXMPPManager].managerObjectContext;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;2.创建查询请求</span><br><span class="line">    NSFetchRequest *fetchRequest &#x3D; [NSFetchRequest fetchRequestWithEntityName:@&quot;XMPPMessageArchiving_Message_CoreDataObject&quot;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;3.设置过滤条件(提取当前用户jid,好友jid)</span><br><span class="line">    NSPredicate *predicate &#x3D; [NSPredicate predicateWithFormat:@&quot;bareJidStr &#x3D;&#x3D; %@ And streamBareJidStr &#x3D;&#x3D; %@&quot;, self.chatToJid.bare,[XMPPManager sharedXMPPManager].stream.myJID.bare];</span><br><span class="line">    fetchRequest.predicate &#x3D; predicate;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;4.设置排序(时间升序)</span><br><span class="line">    NSSortDescriptor *sortDescriptor &#x3D; [[NSSortDescriptor alloc] initWithKey:@&quot;timestamp&quot; ascending:YES];</span><br><span class="line">    fetchRequest.sortDescriptors &#x3D; @[sortDescriptor];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;5.执行请求</span><br><span class="line">    NSError *error &#x3D; nil;</span><br><span class="line">    NSArray *fetchedResult &#x3D; [managerObjectContext executeFetchRequest:fetchRequest error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    return fetchedResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;滚动到最底部</span><br><span class="line">- (void)scrollToBottomWithAnimated:(BOOL)animated&#123;</span><br><span class="line">    </span><br><span class="line">    if (animated &amp;&amp; [self.messageContent numberOfSections] &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">        NSInteger lastSectionIndex &#x3D; [self.messageContent numberOfSections] - 1;</span><br><span class="line">        NSInteger lastRowIndex &#x3D; [self.messageContent numberOfRowsInSection:lastSectionIndex] - 1;</span><br><span class="line">        </span><br><span class="line">        if (lastRowIndex &gt; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            NSIndexPath *lastIndexPath &#x3D; [NSIndexPath indexPathForRow:lastRowIndex inSection:lastSectionIndex];</span><br><span class="line">            [self.messageContent scrollToRowAtIndexPath:lastIndexPath atScrollPosition: UITableViewScrollPositionBottom animated:animated];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark UITableViewDataSourceDelegate</span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</span><br><span class="line">    return self.allMessageArray.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];</span><br><span class="line">    if (nil &#x3D;&#x3D; cell) &#123;</span><br><span class="line">        cell &#x3D; [[UITableViewCell alloc] initWithStyle:(UITableViewCellStyleValue1) reuseIdentifier:@&quot;cell&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    XMPPMessageArchiving_Message_CoreDataObject *chatMessage &#x3D; self.allMessageArray[indexPath.row];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断聊天信息是发出去的 还是接受进来的，在cell上显示不一样的样式</span><br><span class="line">    if (chatMessage.isOutgoing &#x3D;&#x3D; YES) &#123;</span><br><span class="line">        cell.detailTextLabel.text &#x3D; chatMessage.body;</span><br><span class="line">        cell.textLabel.text &#x3D; @&quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cell.textLabel.text &#x3D; chatMessage.body;</span><br><span class="line">        cell.detailTextLabel.text &#x3D; @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.messageTextView.text &#x3D; @&quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1690826-943c7c9b89585e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Use Test_XMPP And Spark Chat.png"></p><p>　　以上就是将XMPP添加到工程，实现基于XMPP的登入、注册、聊天功能，还有一大批别的功能有待探索，之后将进行持续的更新。</p><p>####总结<br>1.XMPP框架中所有的连接、登入、注册、授权、失去连接等操作的回调都是通过XMPPStream来管理；<br>2.使用XMPP开发即时通信，大部分功能都是通过回调XMPPStreamDelegate协议中的方法来实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说明：在&lt;a href=&quot;http://www.jianshu.com/p/7c80a61c8de6&quot;&gt;即时通信系列XMPP之搭建本地服务器&lt;/a&gt;中阐述了通过XAMPP、Openfire工具搭建基于XMPP的服务器端，并使用spark软件进行XMPP客户端的调试。在本文中主要阐述将XMPP添加到工程中，实现iOS中基于XMPP的即时通信。&lt;br&gt;####项目环境配置&lt;br&gt;　　使用CocoaPods导入XMPP框架，如果不会CocoaPods，点击&lt;a href=&quot;http://www.jianshu.com/p/5c66c0c1ee87&quot;&gt;CocoaPods安装及使用教程&lt;/a&gt;，或者&lt;a href=&quot;http://www.jianshu.com/p/e2d018758842&quot;&gt;手动导入XMPP框架&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;####创建XMPP管理类&lt;br&gt;　　为了让XMPP不会对工程中其它业务代码具有侵入性，方便我们管理整个关于XMPP的逻辑处理，通常会采用单例模式新建一个专门的管理类，为此，在工程中创建一个继承自NSObject的XMPPManger，为了能够在代码中方便调用XMPPStreamDelegate的方法，让其遵守XMPPStreamDelegate协议。&lt;br&gt;　　XMPP框架中所有的连接、登入、注册、授权、失去连接等操作的回调都是通过XMPPStream来管理，所以XMPPManger必须有一个XMPPStream实例。其它的还包括进行添加好友、删除好友、获取好友列表等功能的XMPPRoster；消息保存组件XMPPMessageArchiving等。&lt;/p&gt;
&lt;p&gt;######XMPPManager.h&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="XMPP" scheme="http://example.com/tags/XMPP/"/>
    
    <category term="即时通讯" scheme="http://example.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS 即时通信系列之XMPP搭建本地服务器</title>
    <link href="http://example.com/2016/08/01/iOS%20%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E5%88%97%E4%B9%8BXMPP%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2016/08/01/iOS%20%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%B3%BB%E5%88%97%E4%B9%8BXMPP%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2016-08-01T08:16:26.000Z</published>
    <updated>2020-09-26T14:00:48.398Z</updated>
    
    <content type="html"><![CDATA[<p>说明：本文主要阐述如何使用XAMPP、Openfire工具基于XMPP搭建本地服务器、实现即时通信。<br>####即时通信</p><ul><li>######什么是即时通信？<br>  <a href="http://baike.baidu.com/link?url=BFEpJj5zfywwNDNq1ClDZao5RqHeNrlTBXao8AbH9d7SfuvWue2QQnFNSZ6MB9j7Ud7fUk-HZkAl5dgtCufKXa">即时通信</a>(instant message，IM)是指能够即时发送和接收互联网消息等的业务。它是目前Internet上最为流行的一种通讯方式。即时通讯有多种实现方式，例如：XMPP、环信、融云等。本文则对XMPP的使用进行介绍。</li></ul><p>####XMPP</p><ul><li>######什么是XMPP?<br>  <a href="http://baike.baidu.com/link?url=IgiryPUbcsXSyTFjpV4eAQLoI-Wnkj9yNBc3jMciM3GwOpazd_tSWmHCf8LL-ThIvawI59qHXcNZ56N4smMDlK">XMPP</a>(XML，Messages，Presence，Protocol)是可扩展通讯和表示协议，基于XML(可扩展标记语言)，可用于即时通信(IM)。相比其余三种<a href="http://baike.baidu.com/item/IM%E5%8D%8F%E8%AE%AE">IM协议</a>(IMPP、PRIM、SIMPLE)，XMPP最为灵活。它是基于XML的协议，继承了在XML环境中灵活的发展性，所以基于XMPP的应用具有超强的可扩展性。</li><li>######XMPP的优点<a id="more"></a></li></ul><p>1.开放：XMPP协议是自由、开放、公开的，并且易于了解。 而且在客户端、服务器 、组件 、源码库等方面，都已经各自有多种实现。<br>2.标准：互联网工程工作小组（ IETF）已经将Jabber的核心XML流协议以XMPP之名，正式列为认可的实时通信及Presence技术。 而XMPP的技术规格已被定义在RFC 3920及RFC 3921。任何IM供应商在遵循XMPP协议下，都可与Google Talk实现连接。<br>3.证实可用：第一个Jabber(现在XMPP)技术是Jeremie Miller在1998年开发的，现在已经相​​当稳定；数以百计的开发者为XMPP技术而努力。 今日的互联网上有数以万计的XMPP服务器运作着，并有数以百万计的人们使用XMPP实时传讯软件。<br>4.分散式：XMPP网络的架构和电子邮件十分相像；XMPP核心协议通信方式是先创建一个stream，XMPP以TCP传递XML数据流，没有中央主服务器。 任何人都可以运行自己的XMPP服务器，使个人及组织能够掌控他们的实时传讯体验。<br>5.安全：任何XMPP协议的服务器可以独立于公众XMPP网络（例如在企业内部网络中），而使用SASL及TLS等技术的可靠安全性，已自带于核心XMPP技术规格中。<br>6.可扩展：XML 命名空间的威力可使任何人在核心协议的基础上建造定制化的功能；为了维持通透性，常见的扩展由XMPP标准基金会。<br>7.弹性佳：XMPP除了可用在实时通信的应用程序，还能用在网络管理、内容供稿、协同工具、文件共享、游戏、远程系统监控等。<br>8.多样性：用XMPP协议来建造及布署实时应用程序及服务的公司及开放源代码计划分布在各种领域；用XMPP技术开发软件，资源及支持的来源是多样的，使得使你不会陷于被“绑架”的困境。</p><ul><li>######XMPP的缺点<ol><li>数据负载过重：随着通常超过70％的XMPP协议的服务器的数据流量的存在和近60％的被重复转发，XMPP协议目前拥有一个大型架空中存在的数据提供给多个收件人。 新的议定书正在研究，以减轻这一问题。</li><li>没有二进制传输：XMPP协议的方式被编码为一个单一的长的XML文件，因此无法提供修改二进制数据。 因此， 文件传输协议一样使用外部的HTTP。 如果不可避免，XMPP协议还提供了带编码的文件传输的所有数据使用的Base64。 至于其他二进制数据加密会话（encrypted conversations）或图形图标（graphic icons）以嵌入式使用相同的方法。</li></ol></li></ul><p>####XMPP实现即时通信</p><ul><li>#####条件与工具</li><li>######条件<br>  实现即时通信至少需要一个服务器端、两个客户端。下面我们准备需要的环境：XMPP服务器、XMPP客户端(辅助调试)。</li><li>######工具<br>  辅助工具：XAMPP、Openfire、spark、JDK(也可以去<a href="http://xmpp.org/">XMPP官网</a>下载使用别的工具)</li><li>#####XMPP服务器搭建</li><li>######XAMPP<br>XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。是一个易于安装且包含MySQL、PHP和Perl的Apache发行版，非常容易安装和使用，只需<a href="https://www.baidu.com/link?url=CyQf3Nzkbhn5BPDyu1Q0YRuuH-beKbesZiw7r1Tve87vWin3uk1WLK1zlERJQheg48i8gYwe6y3BgXjkFSWQllDSfzlr4D_CxfLUOHWauhC&wd=&eqid=bfda812a00039a6200000003579ed8c1">下载</a>(Mac版)、解压缩、启动即可。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1690826-0730b381ebb47e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 1.png"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-28955d6fea8887df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 2.png"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-6c35f1ba19ac0188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 3.png"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-59d886f00979cd19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 4.png"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-295336aa4ecf6adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 5.png"><br><img src="http://upload-images.jianshu.io/upload_images/1690826-b32d24d72d9b3758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Step 6.png"></p><p>  接下来我们先对Openfire进行配置。</p><ul><li>######Openfire<br>  Openfire采用Java开发，是开源的实时协作(RTC)服务器，基于XMPP(Jabber)协议。其安装和使用都非常简单，利用Web进行管理。单台服务器可支持上万并发用户。因为Openfire服务是基于JAVA语言写的，所以电脑必须要有java运行环境，需要安装JDK成功后才能进行Openfire的安装。<br>  下载Mac版JDK<a href="https://www.baidu.com/link?url=rmv6AXK8Vy1JYeulwC0GWqk0hD8YhBDYypzyFs7CD1cxSQoXHEq7PA9YoJCeeMasW0NEQTfkVfrxTlj9anfS8yRtAO7_yd5bKVay9XDC9t7&wd=&eqid=d834309e000240ac00000003579ee6be">(下载JDK_8u101_macosx_x64_8.0.1010.13)</a>,安装过程就不在此累述，如果不会安装可以点击<a href="http://jingyan.baidu.com/article/e4d08ffdb7a8050fd2f60df1.html">JDK安装教程</a>。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1690826-ef08d3bdbcaea310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JDK.png"></p><p>  下载Mac版Openfire<a href="http://www.igniterealtime.org/downloads/download-landing.jsp?file=openfire/openfire_4_0_2.dmg">(下载Openfire_4_0_2)</a> ,安装成功时候我们可以在电脑的系统偏好设置里面打开这个软件。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-a7c27aca73a4e78b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire.png"> </p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-b2ead50fc4339f91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Install Success.png"></p><p>点击打开, Status显示Running表示服务器打开可以运行；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-edd35fd6af3af311.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire Running.png"></p><p>点击Open Admin Console 打开Openfile的控制平台进行相关配置选择-&gt;简体中文点击-&gt; Continue</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-484e996c3e26c992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire Step 1.png"></p><p>域名使用127.0.0.1（本机作为服务器）</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-b88b854a833792f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire Step 2.png"></p><p>Openfile需要链接一个数据库来存储我们的账号信息，以及聊天的记录</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-b398d40fc452b2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire Step 3.png"></p><p>前往文件夹：/usr/local 右击Openfile-&gt;显示简介，将其访问权限改成-&gt;读与写；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-15b15ffa83a8987e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Change The Read And Write Access.png"></p><p>点击resource-&gt;database，可以看到database下有个openfile_mysql.sql文件，这个文件就是我们接下来要用的，粘贴到桌面以备使用；回到XAMPP中的Step 6单击phpMyAdmin，进入到XAMPP操作界面创建并导入数据库；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-e6f1d88212bc62d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="XAMPP Inport DataBase.png"></p><p>单击执行，导入成功后我们会发现Test_XMPP数据库里面有34张表；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-5112cc6ea2cb5bfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="XAMPP Increase In 34 Table.png"></p><p>然后回到Openfile配置页面将【host name】改为127.0.0.1，【database-name】改为Test_XMPP，之后按提示设置并填写信息；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-5cb813f305ea78c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting User And Password.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-471c07d1bed302d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Finish Install.png"></p><p>登录到管理控制平台可以查看服务器的相关信息；</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-2e3198b5dbb07df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Openfire Server.png"></p><ul><li>#####XMPP客户端环境搭建<br>  上面通过XAMPP和Openfire搭建了一个服务器，接下来通过spark<a href="http://www.igniterealtime.org/downloads/download-landing.jsp?file=spark/spark_2_7_7.dmg">(Mac版spark_2_7_7下载)</a>进行辅助调试。XMPP系统的一个设计标准是必须支持简单的客户端。事实上XMPP系统架构对客户端只有很少的几个限制，一个XMPP客户端必须支持的功能有：<br>  1. 通过TCP套接字与XMPP服务器进行通信；<br>  2. 解析组织好的XML信息包；<br>  3. 理解消息数据类型。<br>所以，只要客户端满足上述三个功能，就可以实现基于XMPP的即时通信。<br>  安装完spark后，通过账户创建一个新的账户进行登入，可以从服务器(用户/组)看到，新创建的账户处于在线状态，而admin账户由于没有登入，所以就处于离线状态。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1690826-7b2746ded8bd2a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spark.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-ce841f3fae2d7eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Login.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-6aaba0a784c82004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server.png"></p><p>  除了spark,我们还可以在<a href="http://xmpp.org/">XMPP官网</a>下载Adium等客户端软件进行调试，其实Mac自带的iMessage也能调试，只要客户端满足之前所述XMPP客户端所必须支持的三个功能，那么任何两个客户端都能够实现即时通信；接下来我们就实现下iMessage和spark之间进行即时通信；<br>  打开iMessage-&gt;添加账户-&gt;其他“信息”账户-&gt;继续；在账户类型里选择Jabber(注:XMPP前身)，用户名填写格式为：用户名@服务器名称，服务器名称可以在服务器的属性查看，填入密码，勾选“自动查找服务器和端口”，点击登入；登入之后我们可以添加一个在spark中登入的账户，添加之后就可以进行通话了，效果如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-5696b611198d2769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iMessage And spark Communication.png"></p><p>上面是客户端与客户端通信，接下来通过服务器给所有在线客户打招呼！</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-630a612ceb95267d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server Send Message.png"></p><p>客户端接收到的消息。</p><p><img src="http://upload-images.jianshu.io/upload_images/1690826-a722c2a3958f41ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Client Receiver Message.png"></p><p>好了，Openfire服务器的搭建及客户端环境的搭建就告一段落了，相信看到这里，你已经对基于XMPP的即时通信有了大概的了解，在下一篇中将实现在iOS工程中加入XMPP实现登入、注册、聊天，有兴趣的话可以去看看。</p><p>####总结</p><ol><li>基于XMPP的8大特性（开放、标准、证实可用、分散、安全、可扩展、弹性佳、多样性），被开发出基于XMPP的软件越来越多；</li><li>XMPP客户端需要支持的功能：<br>  1).通过TCP套接字与XMPP服务器进行通信；<br>  2).解析组织好的XML信息包；<br>  3).理解消息数据类型。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;说明：本文主要阐述如何使用XAMPP、Openfire工具基于XMPP搭建本地服务器、实现即时通信。&lt;br&gt;####即时通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;######什么是即时通信？&lt;br&gt;  &lt;a href=&quot;http://baike.baidu.com/link?url=BFEpJj5zfywwNDNq1ClDZao5RqHeNrlTBXao8AbH9d7SfuvWue2QQnFNSZ6MB9j7Ud7fUk-HZkAl5dgtCufKXa&quot;&gt;即时通信&lt;/a&gt;(instant message，IM)是指能够即时发送和接收互联网消息等的业务。它是目前Internet上最为流行的一种通讯方式。即时通讯有多种实现方式，例如：XMPP、环信、融云等。本文则对XMPP的使用进行介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####XMPP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;######什么是XMPP?&lt;br&gt;  &lt;a href=&quot;http://baike.baidu.com/link?url=IgiryPUbcsXSyTFjpV4eAQLoI-Wnkj9yNBc3jMciM3GwOpazd_tSWmHCf8LL-ThIvawI59qHXcNZ56N4smMDlK&quot;&gt;XMPP&lt;/a&gt;(XML，Messages，Presence，Protocol)是可扩展通讯和表示协议，基于XML(可扩展标记语言)，可用于即时通信(IM)。相比其余三种&lt;a href=&quot;http://baike.baidu.com/item/IM%E5%8D%8F%E8%AE%AE&quot;&gt;IM协议&lt;/a&gt;(IMPP、PRIM、SIMPLE)，XMPP最为灵活。它是基于XML的协议，继承了在XML环境中灵活的发展性，所以基于XMPP的应用具有超强的可扩展性。&lt;/li&gt;
&lt;li&gt;######XMPP的优点</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="XMPP" scheme="http://example.com/tags/XMPP/"/>
    
    <category term="即时通讯" scheme="http://example.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS 获取本地视频的缩略图</title>
    <link href="http://example.com/2016/07/14/iOS%20%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    <id>http://example.com/2016/07/14/iOS%20%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE/</id>
    <published>2016-07-14T04:42:57.000Z</published>
    <updated>2020-09-26T14:00:59.968Z</updated>
    
    <content type="html"><![CDATA[<p>首先添加AVFoundation和CoreMedia.framework</p><pre><code>+(UIImage *)getImage:(NSString *)videoURL&#123;    AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:videoURL] options:nil];    AVAssetImageGenerator *gen = [[AVAssetImageGenerator alloc] initWithAsset:asset];    gen.appliesPreferredTrackTransform = YES;</code></pre><a id="more"></a><pre><code>    CMTime time = CMTimeMakeWithSeconds(0.0, 600);    NSError *error = nil;    CMTime actualTime;    CGImageRef image = [gen copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];    UIImage *thumb = [[UIImage alloc] initWithCGImage:image];    CGImageRelease(image);    return thumb;&#125;</code></pre><p>另一种方法</p><pre><code>MPMoviePlayerController *moviePlayer = [[MPMoviePlayerController alloc]initWithContentURL:videoURL]; moviePlayer.shouldAutoplay = NO; UIImage *thumbnail = [moviePlayer thumbnailImageAtTime:time timeOption:MPMovieTimeOptionNearestKeyFrame];</code></pre><p>//这个也一样</p><pre><code>+(UIImage *)fFirstVideoFrame:(NSString *)path &#123;     MPMoviePlayerController *mp = [[MPMoviePlayerController alloc]                                initWithContentURL:[NSURL fileURLWithPath:path]];     UIImage *img = [mp thumbnailImageAtTime:0.0                              timeOption:MPMovieTimeOptionNearestKeyFrame];     [mp stop];     [mp release];     return img; &#125;</code></pre><p>转：blog.sina.com.cn/s/blog_6d01cce301019xym.html</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先添加AVFoundation和CoreMedia.framework&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(UIImage *)getImage:(NSString *)videoURL&amp;#123;

    AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:videoURL] options:nil];

    AVAssetImageGenerator *gen = [[AVAssetImageGenerator alloc] initWithAsset:asset];

    gen.appliesPreferredTrackTransform = YES;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="视频缩略图" scheme="http://example.com/tags/%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    
  </entry>
  
</feed>
